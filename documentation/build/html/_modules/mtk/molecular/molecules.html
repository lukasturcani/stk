

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mtk.molecular.molecules &mdash; mtk  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mtk  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mtk
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mtk</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mtk.molecular.molecules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mtk.molecular.molecules</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines classes which describe molecules.</span>

<span class="sd">There are a couple of major classes defined here. The most important</span>
<span class="sd">ones are :class:`StructUnit` and :class:`MacroMolecule`. Here is an</span>
<span class="sd">overview of their role and interaction. This is followed by a</span>
<span class="sd">step-by-step guide to macromolecular assembly.</span>

<span class="sd">:class:`StructUnit` represents the monomers that make up</span>
<span class="sd">macromolecules. These are commonly refered to as ``building blocks`` in</span>
<span class="sd">the documentation. :class:`StructUnit` holds information concerning</span>
<span class="sd">only a single building block molecule. For example, the number of atoms</span>
<span class="sd">and bonds a building block may have. It also has information about the</span>
<span class="sd">functoinal groups present in the building block molecule (see</span>
<span class="sd">:class:`.FGInfo`). The class also allows manipulation of the lone</span>
<span class="sd">building block molecule, such as rotations and translations.</span>

<span class="sd">The :class:`StructUnit` should be inherited as necessary. For example,</span>
<span class="sd">:class:`StructUnit2` adds manipulations relavant to molecules with 2</span>
<span class="sd">functional groups. :class:`StructUnit3` adds manipulations relavant to</span>
<span class="sd">molecules with 3 or more functional groups. If you have a monomer which</span>
<span class="sd">needs specific information or manipulations, give it its own class.</span>

<span class="sd">The :class:`MacroMolecule` class represents an assembled macromolecule.</span>
<span class="sd">It requires at least 2 basic pieces of information: which monomers are</span>
<span class="sd">used to assemble the macromolecule and what the topology/structure</span>
<span class="sd">of the macromolecule is.</span>

<span class="sd">:attr:`MacroMolecule.building_blocks` holds a :class:`list` of</span>
<span class="sd">:class:`StructUnit` instances. These represent the monomers which</span>
<span class="sd">make up the macromolecule. Only one :class:`StructUnit` instance per</span>
<span class="sd">monomer type is held. So if 4 of one type of monomer and 2 of another</span>
<span class="sd">type of monomer form a macromolecule, only 2 :class:`StructUnit`</span>
<span class="sd">instances are in :attr:`MacroMolecule.building_blocks`.</span>

<span class="sd">:attr:`MacroMolecule.topology` holds a :class:`Topology` instance. This</span>
<span class="sd">instance is responsible for assembling the macromolecule from the</span>
<span class="sd">building blocks. The building should happen in</span>
<span class="sd">:meth:`MacroMolecule.__init__` via :meth:`.Topology.build`. The</span>
<span class="sd">:meth:`~.Topology.build` method places the assembled macromoleclue in</span>
<span class="sd">:attr:`MacroMolecule.mol` as an ``rdkit`` molecule.</span>

<span class="sd">:class:`StructUnit` labels atoms in the functional groups of the</span>
<span class="sd">building blocks as either ``&#39;bonder&#39;`` or ``&#39;del&#39;`` (see its</span>
<span class="sd">documentation). This tells the :class:`.Topology` instance which atoms</span>
<span class="sd">form bonds and which are removed during assembly.</span>

<span class="sd">A more detailed description of macromolecular assembly.</span>
<span class="sd">-------------------------------------------------------</span>

<span class="sd">This is a step-by-step guide of how macromolecular assembly is carried</span>
<span class="sd">out and what the classes do.</span>

<span class="sd">First you create :class:`StructUnit` instances of the building blocks</span>
<span class="sd">which make up the macromolecule:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    bb = StructUnit(&#39;/path/to/struct/file.mol2&#39;, &#39;amine&#39;)</span>

<span class="sd">The :class:`StructUnit` instances are initialized using paths to</span>
<span class="sd">molecular structure files. (Initializing a :class:`StructUnit`</span>
<span class="sd">automatically completes steps 1 to 4.)</span>

<span class="sd">    1. Place an ``rdkit`` instance of the molecule into</span>
<span class="sd">       :attr:`StructUnit.mol`, i.e.</span>

<span class="sd">       .. code-block:: python</span>

<span class="sd">           bb.mol  # &lt;rdkit.Chem.rdchem.Mol at 0x7f961a8f1f80&gt;</span>

<span class="sd">    2. Scan the path of the structure file for the name of a functional</span>
<span class="sd">       group. (Alternatively the name of a functional group can be</span>
<span class="sd">       supplied to the initializer).</span>

<span class="sd">       .. code-block:: python</span>

<span class="sd">           bb.func_group.name  # &#39;amine&#39;</span>

<span class="sd">Which functional groups are recognized by ``mtk``?</span>

<span class="sd">The module :mod:`.fg_info` defines the class :class:`.FGInfo` and a</span>
<span class="sd">:class:`list` of instances of this class called</span>
<span class="sd">:data:`functional_groups`. If you put an :class:`.FGInfo` instance into</span>
<span class="sd">:data:`functional_groups`, the functional group will be recognized.</span>

<span class="sd">    3. Place the :class:`.FGInfo` instance of the functional group into</span>
<span class="sd">       :attr:`StructUnit.func_grp`.</span>

<span class="sd">    4. Using :class:`.FGInfo`, tag atoms in the building block as</span>
<span class="sd">       either ``&#39;bonder&#39;`` or ``&#39;del&#39;``. ``&#39;bonder&#39;`` signifies that</span>
<span class="sd">       the atoms form a bond during macromolecular assembly, while</span>
<span class="sd">       ``&#39;del&#39;`` means they are deleted.</span>

<span class="sd">    5. Give the :class:`StructUnit` and :class:`.Topology` instances to</span>
<span class="sd">       the macromolecule&#39;s initializer.</span>

<span class="sd">       .. code-block:: python</span>

<span class="sd">           macro_mol = MacroMolecule([bb1, bb2], Topology())</span>

<span class="sd">       Normally, :class:`MacroMolecule` and :class:`.Topology` will</span>
<span class="sd">       not be used directly. Instead, classes derived from these</span>
<span class="sd">       will be used. For example,</span>

<span class="sd">           .. code-block:: python</span>

<span class="sd">               macro_mol = Polymer([bb1, bb2], Linear(&quot;AB&quot;, [0, 0], 3))</span>

<span class="sd">    6. Run :meth:`.Topology.build` inside</span>
<span class="sd">       :meth:`MacroMolecule.__init__`.</span>

<span class="sd">    7. The details of :meth:`.Topology.build` will vary depending on</span>
<span class="sd">       the :class:`.Topology` class used. However, the basic structure</span>
<span class="sd">       is the same (steps 8 - 10).</span>

<span class="sd">    8. Combine the ``rdkit`` molecules in :attr:`StructUnit.mol`</span>
<span class="sd">       into a single ``rdkit`` molecule. Make sure that the building</span>
<span class="sd">       blocks are arranged in the shape of the macromolecule. All the</span>
<span class="sd">       manipulations available through :class:`StructUnit` are</span>
<span class="sd">       useful here to make sure all building blocks are oriented</span>
<span class="sd">       correctly when forming the macromolecule.</span>

<span class="sd">    9. Create bonds between all the disjoined building block</span>
<span class="sd">       molecules. This is where the tagging done by :class:`StructUnit`</span>
<span class="sd">       is needed.</span>

<span class="sd">    10. Delete all atoms tagged for deletion.</span>

<span class="sd">After all this you should have a ``rdkit`` instance of the</span>
<span class="sd">macromolecule which should be placed into :attr:`MacroMolecule.mol`.</span>

<span class="sd">Extending mtk: Adding new macromolecules.</span>
<span class="sd">-----------------------------------------</span>

<span class="sd">To add new macromolecules create a new class which inherits</span>
<span class="sd">:class:`MacroMolecule`.</span>

<span class="sd">If you&#39;re adding a new class of macromolecules, it quite likely you</span>
<span class="sd">want to add a new :class:`.Topology` class. See the</span>
<span class="sd">:mod:`.topologies.base` for guidance on adding these. The topology</span>
<span class="sd">class does the assembly of the macromolecule from the building blocks.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">rdkit.Geometry.rdGeometry</span> <span class="k">as</span> <span class="nn">rdkit_geo</span>
<span class="kn">import</span> <span class="nn">rdkit.Chem.AllChem</span> <span class="k">as</span> <span class="nn">rdkit</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="k">import</span> <span class="n">rdMolTransforms</span>

<span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">DataStructs</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="k">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">total_ordering</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">euclidean</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">euclidean_distances</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">ChainMap</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">topologies</span>
<span class="kn">from</span> <span class="nn">.fg_info</span> <span class="k">import</span> <span class="n">functional_groups</span>
<span class="kn">from</span> <span class="nn">.energy</span> <span class="k">import</span> <span class="n">Energy</span>
<span class="kn">import</span> <span class="nn">pywindow</span>
<span class="kn">from</span> <span class="nn">..convenience_tools</span> <span class="k">import</span> <span class="p">(</span><span class="n">flatten</span><span class="p">,</span> <span class="n">periodic_table</span><span class="p">,</span>
                                 <span class="n">normalize_vector</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">,</span>
                                 <span class="n">vector_theta</span><span class="p">,</span> <span class="n">mol_from_mae_file</span><span class="p">,</span>
                                 <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">,</span>
                                 <span class="n">atom_vdw_radii</span><span class="p">,</span> <span class="n">bond_dict</span><span class="p">,</span> <span class="n">Cell</span><span class="p">)</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="c1"># Toggles caching when making molecules.</span>
<span class="n">CACHE_SETTINGS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ON&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>


<div class="viewcode-block" id="Cached"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Cached">[docs]</a><span class="k">class</span> <span class="nc">Cached</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metaclass for creating classes which create cached instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sig</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">arguments</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_key</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="s1">&#39;building_blocks&#39;</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;topology&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">and</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="CachedStructUnit"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.CachedStructUnit">[docs]</a><span class="k">class</span> <span class="nc">CachedStructUnit</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metaclass for making :class:`StructUnit` create cached instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Get the arguments given to the initializer as a dictionary</span>
        <span class="c1"># mapping argument name to argument value.</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sig</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">arguments</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>

        <span class="c1"># Ensure a valid file type was provided.</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_funcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">((</span><span class="s1">&#39;Unable to initialize&#39;</span>
                             <span class="s1">&#39; from &quot;</span><span class="si">{}</span><span class="s1">&quot; files.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_funcs</span><span class="p">[</span><span class="n">ext</span><span class="p">](</span><span class="n">sig</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>

        <span class="c1"># Get the name of the functional group provided to the</span>
        <span class="c1"># initializer or get it from the path.</span>
        <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;functional_group&#39;</span><span class="p">]:</span>
            <span class="n">fg</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;functional_group&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">functional_groups</span> <span class="k">if</span>
                       <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_key</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">and</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The most basic class representing molecules.</span>

<span class="sd">    This class defines the operations which any class</span>
<span class="sd">    describing molecules should inherit or may find useful. Examples of</span>
<span class="sd">    such are :class:`StructUnit` and :class:`MacroMolecule`. This class</span>
<span class="sd">    should not be used directly.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">        An ``rdkit`` molecule instance representing the molecule.</span>

<span class="sd">    inchi : :class:`str`</span>
<span class="sd">        The InChI of the molecule.</span>

<span class="sd">    energy : :class:`.Energy`</span>
<span class="sd">        Handles all things energy.</span>

<span class="sd">    optimized : :class:`bool`</span>
<span class="sd">        Indicates whether a :class:`Molecule` has been passed through</span>
<span class="sd">        an optimization function or not.</span>

<span class="sd">    name : :class:`str`</span>
<span class="sd">        A name which can be optionally given to the molecule for easy</span>
<span class="sd">        identification.</span>

<span class="sd">    note : :class:`str`</span>
<span class="sd">        A note or comment about the molecule. Purely optional but can</span>
<span class="sd">        be useful for labelling and debugging.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">note</span> <span class="o">=</span> <span class="n">note</span>

<div class="viewcode-block" id="Molecule.all_atom_coords"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.all_atom_coords">[docs]</a>    <span class="k">def</span> <span class="nf">all_atom_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yields the coordinates of atoms in :attr:`mol`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The yielded :class:`tuple` has the form</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                (32, numpy.array([12, 34, 3]))</span>

<span class="sd">            Where the first element is the atom id and the second</span>
<span class="sd">            element is an array holding the coordinates of the atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the conformer from the rdkit instance.</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>

        <span class="c1"># Go through all the atoms and ask the conformer to return</span>
        <span class="c1"># the position of each atom. This is done by supplying the</span>
        <span class="c1"># conformers `GetAtomPosition` method with the atom&#39;s id.</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">atom_position</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">atom_position</span><span class="p">])</span></div>

<div class="viewcode-block" id="Molecule.atom_coords"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.atom_coords">[docs]</a>    <span class="k">def</span> <span class="nf">atom_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return coordinates of an atom.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_id : :class:`int`</span>
<span class="sd">            The id of the atom whose coordinates are desired.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            An array holding the x, y and z coordinates of the atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="n">atom_position</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">atom_position</span><span class="p">])</span></div>

<div class="viewcode-block" id="Molecule.atom_distance"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.atom_distance">[docs]</a>    <span class="k">def</span> <span class="nf">atom_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom1_id</span><span class="p">,</span> <span class="n">atom2_id</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the distance between 2 atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom1_id : :class:`int`</span>
<span class="sd">            The id of the first atom.</span>

<span class="sd">        atom2_id : :class:`int`</span>
<span class="sd">            The id of the second atom.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`scipy.double`</span>
<span class="sd">            The distance between the first and second atoms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the atomic positions of each atom and use the scipy</span>
        <span class="c1"># function to calculate their distance in Euclidean space.</span>
        <span class="n">atom1_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom1_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="n">atom2_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom2_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">atom1_coords</span><span class="p">,</span> <span class="n">atom2_coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.atom_symbol"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.atom_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">atom_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symbol of the atom with id `atom_id`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_id : :class:`int`</span>
<span class="sd">            The id number of the atom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`str`</span>
<span class="sd">            The atomic symbol of the atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_cavity_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">conformer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates diameter of the molecule from `origin`.</span>

<span class="sd">        The cavity is measured by finding the atom nearest to</span>
<span class="sd">        `origin`, correcting for van der Waals diameter and multiplying</span>
<span class="sd">        by -2.</span>

<span class="sd">        This function should not be used directly. Use</span>
<span class="sd">        :meth:`cavity_size` instead, which finds the optimal value of</span>
<span class="sd">        `origin` to use.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin : :class:`numpy.array`</span>
<span class="sd">            Holds the x, y and z coordinate of the position from which</span>
<span class="sd">            the cavity is measured.</span>

<span class="sd">        conformer : :class:`int`</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The (negative) diameter of the molecules cavity.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atom_vdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom_vdw_radii</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span>
                            <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()])</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="n">atom_vdw</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

<div class="viewcode-block" id="Molecule.cavity_size"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.cavity_size">[docs]</a>    <span class="k">def</span> <span class="nf">cavity_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the diameter of the molecule&#39;s cavity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The diameter of the molecule&#39;s cavity in Angstroms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This function uses _cavity_size() to calculate the cavity</span>
        <span class="c1"># size. _cavity_size() finds the closest atom to `origin` to</span>
        <span class="c1"># get its value of the cavity.</span>

        <span class="c1"># What this function does is finds the value of `origin` which</span>
        <span class="c1"># causes _cavity_size() to calculate the largest possible</span>
        <span class="c1"># cavity.</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="n">icavity</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_cavity_size</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coord</span><span class="o">+</span><span class="n">icavity</span><span class="p">,</span> <span class="n">coord</span><span class="o">-</span><span class="n">icavity</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
        <span class="n">cavity_origin</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cavity_size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">conformer</span><span class="p">),</span>
                                 <span class="n">x0</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span>
                                 <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="n">cavity</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_cavity_size</span><span class="p">(</span><span class="n">cavity_origin</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">cavity</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">cavity</span></div>

<div class="viewcode-block" id="Molecule.center_of_mass"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.center_of_mass">[docs]</a>    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centre of mass of the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            An array holding the coordinates of the center of mass.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        https://en.wikipedia.org/wiki/Center_of_mass</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
        <span class="n">total_mass</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_atom_coords</span><span class="p">(</span><span class="n">conformer</span><span class="p">):</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span><span class="o">.</span><span class="n">GetMass</span><span class="p">()</span>
            <span class="n">total_mass</span> <span class="o">+=</span> <span class="n">mass</span>
            <span class="n">center</span> <span class="o">+=</span> <span class="n">mass</span><span class="o">*</span><span class="n">coord</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">total_mass</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.centroid"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.centroid">[docs]</a>    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroid of the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            A numpy array holding the position of the centroid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">centroid</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_atom_coords</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span></div>

<div class="viewcode-block" id="Molecule.dihedral_strain"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.dihedral_strain">[docs]</a>    <span class="k">def</span> <span class="nf">dihedral_strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">dihedral_SMARTS</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                        <span class="n">target</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span>
                        <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the difference between the average dihedral and target.</span>

<span class="sd">        The differences is a returned as a percent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dihedral_SMARTS : :class:`str`</span>
<span class="sd">            The SMARTS code for the dihedral of interest.</span>

<span class="sd">        target : :class:`float`</span>
<span class="sd">            Float representing the target value for the dihedral angle.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The percent difference between the average dihedral in the</span>
<span class="sd">            molecule and the target value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">dihedral_SMARTS</span><span class="p">)</span>
        <span class="n">atoms_dihedral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

        <span class="n">dihedral_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_dihedral</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_dihedral</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atoms_group</span> <span class="ow">in</span> <span class="n">atoms_dihedral</span><span class="p">:</span>
                <span class="c1"># Calculate the dihedral angle</span>
                <span class="n">dihedral_value</span> <span class="o">=</span> <span class="n">rdMolTransforms</span><span class="o">.</span><span class="n">GetDihedralDeg</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span>
                                    <span class="n">atoms_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">atoms_group</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">atoms_group</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                    <span class="n">atoms_group</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">dihedral_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dihedral_value</span><span class="p">)</span>

            <span class="c1"># Calculate the average dihedral value</span>
            <span class="n">avg_dihedral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dihedral_info</span><span class="p">])</span>
            <span class="c1"># Calculate the relative diff with the target dihedral value</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">avg_dihedral</span><span class="p">)</span> <span class="o">/</span> <span class="n">target</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the molecule does not contain the bond, give 1% strain.</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">diff</span></div>

<div class="viewcode-block" id="Molecule.dump"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a JSON :class:`dict` of the molecule to a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path to the file to which the JSON dict should be</span>
<span class="sd">            written.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json</span><span class="p">(),</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.fromdict"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.fromdict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">,</span> <span class="n">optimized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a :class:`Molecule` from a JSON :class:`dict`.</span>

<span class="sd">        The :class:`Molecule` returned has the class specified in</span>
<span class="sd">        `json_dict`, not :class:`Molecule`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_dict : :class:`dict`</span>
<span class="sd">            A :class:`dict` holding the JSON representation of a</span>
<span class="sd">            molecule.</span>

<span class="sd">        optimized : :class:`bool`, optional</span>
<span class="sd">            The value passed to :attr:`Molecule.optimized`</span>

<span class="sd">        load_names : :class:`bool`, optional</span>
<span class="sd">            If ``True`` then the ``name`` key stored in `json_dict`</span>
<span class="sd">            is loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`Molecule`</span>
<span class="sd">            The molecule represented by `json_dict`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the class of the object.</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]]</span>
        <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;optimized&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimized</span>
        <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;load_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">load_names</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">_json_init</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.graph"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.graph">[docs]</a>    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mathematical graph representing the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`networkx.Graph`</span>
<span class="sd">            A graph where the nodes are the ids of the atoms and the</span>
<span class="sd">            edges are the bonds.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a graph instance and add the atom ids as nodes. Use</span>
        <span class="c1"># the atom ids from each end of a bond to define edges. Do this</span>
        <span class="c1"># for all bonds to account for all edges.</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span>
                           <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">graph</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the InChI of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`str`</span>
<span class="sd">            The InChI of the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_stereochemistry</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolToInchi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>

<div class="viewcode-block" id="Molecule.load"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">optimized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a :class:`Molecule` from a JSON file.</span>

<span class="sd">        The returned :class:`Molecule` has the class specified in the</span>
<span class="sd">        JSON file, not :class:`Molecule`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path holding a JSON representation to a molecule.</span>

<span class="sd">        optimized : :class:`bool`, optional</span>
<span class="sd">            The value passed to :attr:`Molecule.optimized`.</span>

<span class="sd">        load_names : :class:`bool`, optional</span>
<span class="sd">            If ``True`` then the ``name`` key stored in the JSON file</span>
<span class="sd">            is loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`Molecule`</span>
<span class="sd">            The molecule held in `path`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="n">optimized</span><span class="p">,</span> <span class="n">load_names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.max_diameter"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.max_diameter">[docs]</a>    <span class="k">def</span> <span class="nf">max_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the largest distance between 2 atoms in the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple` of form (float, int, int)</span>
<span class="sd">            A :class:`tuple` of the form</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                max_diameter = (312.3, 4, 54)</span>

<span class="sd">            Where the first element is the largest inter-atomic</span>
<span class="sd">            distance in the molecule. The next 2 elements are the ids</span>
<span class="sd">            of the involved atoms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">maxid1</span><span class="p">,</span> <span class="n">maxid2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()),</span>
                                        <span class="mi">2</span><span class="p">)),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_distance</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">conformer</span><span class="p">))</span>

        <span class="n">maxd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_distance</span><span class="p">(</span><span class="n">maxid1</span><span class="p">,</span> <span class="n">maxid2</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="n">maxd</span> <span class="o">+=</span> <span class="p">(</span><span class="n">atom_vdw_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="n">maxid1</span><span class="p">)]</span> <span class="o">+</span>
                 <span class="n">atom_vdw_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="n">maxid2</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">maxd</span><span class="p">,</span> <span class="n">maxid1</span><span class="p">,</span> <span class="n">maxid2</span></div>

<div class="viewcode-block" id="Molecule.mdl_mol_block"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.mdl_mol_block">[docs]</a>    <span class="k">def</span> <span class="nf">mdl_mol_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a V3000 mol block of the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`str`</span>
<span class="sd">            The V3000 mol block representing the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">main_string</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;     RDKit          3D</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;  0  0  0  0  0  0  0  0  0  0999 V3000</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 BEGIN CTAB</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 COUNTS </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> 0 0 0</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 BEGIN ATOM</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;!!!ATOM!!!BLOCK!!!HERE!!!</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 END ATOM</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 BEGIN BOND</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;!!!BOND!!!BLOCK!!!HERE!!!</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 END BOND</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  V30 END CTAB</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;M  END</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;$$$$</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># id atomic_symbol x y z</span>
        <span class="n">atom_line</span> <span class="o">=</span> <span class="s2">&quot;M  V30 </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2:.4f}</span><span class="s2"> </span><span class="si">{3:.4f}</span><span class="s2"> </span><span class="si">{4:.4f}</span><span class="s2"> 0</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">atom_block</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># id bond_order atom1 atom2</span>
        <span class="n">bond_line</span> <span class="o">=</span> <span class="s2">&quot;M  V30 </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> </span><span class="si">{3}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">bond_block</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">main_string</span> <span class="o">=</span> <span class="n">main_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumBonds</span><span class="p">())</span>
        <span class="c1"># Kekulize the mol, which means that each aromatic bond is</span>
        <span class="c1"># converted to a single or double. This is necessary because</span>
        <span class="c1"># .mol V3000 only supports integer bonds. However, this fails</span>
        <span class="c1"># sometimes on big molecules.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rdkit</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">atom_sym</span> <span class="o">=</span> <span class="n">periodic_table</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()]</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
            <span class="n">atom_block</span> <span class="o">+=</span> <span class="n">atom_line</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">atom_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="n">atom_sym</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">bond_id</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">atom1_id</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">atom2_id</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">bond_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBondTypeAsDouble</span><span class="p">())</span>
            <span class="c1"># Ensure that no information was lost when converting</span>
            <span class="c1"># double to int.</span>
            <span class="k">assert</span> <span class="n">bond_order</span> <span class="o">==</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondTypeAsDouble</span><span class="p">()</span>
            <span class="n">bond_block</span> <span class="o">+=</span> <span class="n">bond_line</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bond_id</span><span class="p">,</span> <span class="n">bond_order</span><span class="p">,</span>
                                           <span class="n">atom1_id</span><span class="p">,</span> <span class="n">atom2_id</span><span class="p">)</span>

        <span class="n">main_string</span> <span class="o">=</span> <span class="n">main_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;!!!ATOM!!!BLOCK!!!HERE!!!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">atom_block</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">main_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s2">&quot;!!!BOND!!!BLOCK!!!HERE!!!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bond_block</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.position_matrix"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.position_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the position of all atoms as a matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.matrix`</span>
<span class="sd">            The matrix has a shape ``[3, n]``. Each column holds the x,</span>
<span class="sd">            y and z coordinates of an atom. The index of the column</span>
<span class="sd">            corresponds to the id of the atom in the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">pos_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)])</span>
            <span class="n">pos_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_array</span><span class="p">,</span> <span class="n">pos_vect</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">pos_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.same"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.same">[docs]</a>    <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if `other` has the same molecular structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`Molecule`</span>
<span class="sd">            The :class:`Molecule` instance you are checking has</span>
<span class="sd">            the same structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`bool`</span>
<span class="sd">            Returns ``True`` if the structures match.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inchi</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">inchi</span></div>

<div class="viewcode-block" id="Molecule.rotate"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule by `theta` about `axis`.</span>

<span class="sd">        The rotation occurs about the molecular centroid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : :class:`float`</span>
<span class="sd">            The size of the rotation in radians.</span>

<span class="sd">        axis : :class:`numpy.array`</span>
<span class="sd">            The axis about which the rotation happens.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Save the original position.</span>
        <span class="n">og_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Move the centroid of the molecule to the origin, so that the</span>
        <span class="c1"># rotation occurs about this point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Get the rotation matrix.</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Apply the rotation matrix on the position matrix, to get the</span>
        <span class="c1"># new position matrix.</span>
        <span class="n">new_pos_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="c1"># Apply the rotation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position_from_matrix</span><span class="p">(</span><span class="n">new_pos_mat</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Return the centroid of the molecule to the origin position.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">og_position</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.save_bonders"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.save_bonders">[docs]</a>    <span class="k">def</span> <span class="nf">save_bonders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds atoms tagged with &#39;bonder&#39; to `bonder_ids`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Clear the set in case the method is run twice.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s1">&#39;bonder&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span></div>

<div class="viewcode-block" id="Molecule.set_orientation"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.set_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">set_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule by a rotation from `start` to `end`.</span>

<span class="sd">        Given two direction vectors, `start` and `end`, this method</span>
<span class="sd">        applies the rotation required transform `start` to `end` on</span>
<span class="sd">        the molecule. The rotation occurs about the centroid of the</span>
<span class="sd">        molecule.</span>

<span class="sd">        For example, if the `start` and `end` vectors</span>
<span class="sd">        are 45 degrees apart, a 45 degree rotation will be applied to</span>
<span class="sd">        the molecule. The rotation will be along the appropriate</span>
<span class="sd">        direction.</span>

<span class="sd">        The great thing about this method is that you as long as you</span>
<span class="sd">        can associate a geometric feature of the molecule with a</span>
<span class="sd">        vector, then the molecule can be rotated so that this vector is</span>
<span class="sd">        aligned with `end`. The defined vector can be virtually</span>
<span class="sd">        anything. This means that any geometric feature of the molecule</span>
<span class="sd">        can be easily aligned with any arbitrary axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The difference between this method and</span>
<span class="sd">        :meth:`StructUnit._set_orientation2` is about which point the</span>
<span class="sd">        rotation occurs: centroid of the entire molecule versus</span>
<span class="sd">        centroid of the bonder atoms, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : :class:`numpy.array`</span>
<span class="sd">            A vector which is to be rotated so that it transforms to</span>
<span class="sd">            the `end` vector.</span>

<span class="sd">        end : :class:`numpy.array`</span>
<span class="sd">            This array holds the vector, onto which `start` is rotated.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule in :attr:`~Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Normalize the input direction vectors.</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="c1"># Record the position of the molecule then translate the</span>
        <span class="c1"># centroid to the origin. This is so that the rotation occurs</span>
        <span class="c1"># about this point.</span>
        <span class="n">og_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="c1"># Get the rotation matrix.</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># Apply the rotation matrix to the atomic positions to yield</span>
        <span class="c1"># the new atomic positions.</span>
        <span class="n">new_pos_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

        <span class="c1"># Set the positions of the molecule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position_from_matrix</span><span class="p">(</span><span class="n">new_pos_mat</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">og_center</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span></div>

<div class="viewcode-block" id="Molecule.set_position"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.set_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the centroid of the molecule to `position`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        position : :class:`numpy.array`</span>
<span class="sd">            This array holds the position on which the centroid of the</span>
<span class="sd">            molecule should be placed.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule with the centroid placed at</span>
<span class="sd">            `position`. This is the same instance as that in</span>
<span class="sd">            :attr:`Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conf_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span>

        <span class="c1"># Get the original centroid.</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>
        <span class="c1"># Find out how much it needs to shift to reach `position`.</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">centroid</span>
        <span class="c1"># Apply the shift and get the resulting rdkit conformer object.</span>
        <span class="n">new_conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">conf_id</span><span class="p">)</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">()</span>
        <span class="n">new_conf</span><span class="o">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>

        <span class="c1"># Replace the old rkdit conformer with one where the centroid</span>
        <span class="c1"># is at `position`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">RemoveConformer</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">new_conf</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span></div>

<div class="viewcode-block" id="Molecule.set_position_from_matrix"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.set_position_from_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_position_from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_mat</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set atomic positions of the molecule to those in `pos_mat`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos_mat : :class:`numpy.array`</span>
<span class="sd">            The matrix holds the coordinates on which the atoms of the</span>
<span class="sd">            molecule should be placed.</span>

<span class="sd">            The shape of the matrix is ``[3, n]``. Each column of</span>
<span class="sd">            `pos_mat` represents the coordinates of a single atom. The</span>
<span class="sd">            1st column sets the coordinates of the atom with id of 0.</span>
<span class="sd">            The next column sets the coordinates of the atom with id 1,</span>
<span class="sd">            and so on.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord_mat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos_mat</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">rdkit_geo</span><span class="o">.</span><span class="n">Point3D</span><span class="p">(</span><span class="n">coord_mat</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                      <span class="n">coord_mat</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                      <span class="n">coord_mat</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">conf</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.shift"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the coordinates of all atoms.</span>

<span class="sd">        This does not modify the molecule. A modified copy is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift : :class:`numpy.array`</span>
<span class="sd">            A numpy array holding the value of the shift along each</span>
<span class="sd">            axis.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            A copy of the molecule where the coordinates have been</span>
<span class="sd">            shifted by `shift`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The function does not modify the existing conformer, as a</span>
        <span class="c1"># result a new instance is created and used for modification.</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Conformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

        <span class="c1"># For each atom, get the atomic positions from the conformer</span>
        <span class="c1"># and shift them. Create a new geometry instance from these new</span>
        <span class="c1"># coordinate values. The geometry instance is used by rdkit to</span>
        <span class="c1"># store the coordinates of atoms. Finally, set the conformers</span>
        <span class="c1"># atomic position to the values stored in this newly generated</span>
        <span class="c1"># geometry instance.</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>

            <span class="c1"># Remember the id of the atom you are currently using. It</span>
            <span class="c1"># is used to change the position of the correct atom at the</span>
            <span class="c1"># end of the loop.</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>

            <span class="c1"># `atom_position` in an instance holding in the x, y and z</span>
            <span class="c1"># coordinates of an atom in its &#39;x&#39;, &#39;y&#39; and &#39;z&#39;</span>
            <span class="c1"># attributes.</span>
            <span class="n">atom_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">))</span>

            <span class="c1"># Inducing the shift.</span>
            <span class="n">new_atom_position</span> <span class="o">=</span> <span class="n">atom_position</span> <span class="o">+</span> <span class="n">shift</span>

            <span class="c1"># Creating a new geometry instance.</span>
            <span class="n">new_coords</span> <span class="o">=</span> <span class="n">rdkit_geo</span><span class="o">.</span><span class="n">Point3D</span><span class="p">(</span><span class="o">*</span><span class="n">new_atom_position</span><span class="p">)</span>

            <span class="c1"># Changes the position of the atom in the conformer to the</span>
            <span class="c1"># values stored in the new geometry instance.</span>
            <span class="n">conf</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">new_coords</span><span class="p">)</span>

        <span class="c1"># Create a new copy of the rdkit molecule instance representing</span>
        <span class="c1"># the molecule - the original instance is not to be modified.</span>
        <span class="n">new_mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>

        <span class="c1"># The new rdkit molecule was copied from the one held in the</span>
        <span class="c1"># `mol` attribute, as result it has a copy of its conformer. To</span>
        <span class="c1"># prevent the rdkit molecule from holding multiple conformers</span>
        <span class="c1"># the `RemoveAllConformers` method is run first. The shifted</span>
        <span class="c1"># conformer is then given to the rdkit molecule, which is</span>
        <span class="c1"># returned.</span>
        <span class="n">new_mol</span><span class="o">.</span><span class="n">RemoveAllConformers</span><span class="p">()</span>
        <span class="n">new_mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_mol</span></div>

<div class="viewcode-block" id="Molecule.update_from_mae"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.update_from_mae">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_mae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates molecular structure to match an ``.mae`` file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path of the ``.mae`` file from which the structure</span>
<span class="sd">            should be updated.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to be updated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">conformer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">conformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">mol_from_mae_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Conformer</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">())</span>
        <span class="n">conf</span><span class="o">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">RemoveConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.update_from_mol"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.update_from_mol">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates molecular structure to match an ``.mol`` file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path of the ``.mol`` file from which the structure</span>
<span class="sd">            should be updated.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to be updated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">conformer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">conformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Conformer</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">())</span>
        <span class="n">conf</span><span class="o">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">RemoveConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.update_stereochemistry"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.update_stereochemistry">[docs]</a>    <span class="k">def</span> <span class="nf">update_stereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates stereochemistry tags in :attr:`Molecule.mol`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">()</span>
        <span class="n">rdkit</span><span class="o">.</span><span class="n">AssignAtomChiralTagsFromStructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="n">rdkit</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.write"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Molecule.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a molecular structure file of the molecule.</span>

<span class="sd">        This bypasses the need to the writining functions in ``rdkit``.</span>
<span class="sd">        These have issues with macromolecules due to poor ring finding</span>
<span class="sd">        and sanitization issues.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The `path` to which the molecule should be written.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">write_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.mol&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_mdl_mol_file</span><span class="p">,</span>
                       <span class="s1">&#39;.pdb&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_pdb_file</span><span class="p">}</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">write_func</span> <span class="o">=</span> <span class="n">write_funcs</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
        <span class="n">write_func</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_write_mdl_mol_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a V3000 ``.mol`` file of the molecule</span>

<span class="sd">        This function should not be used directly, only via</span>
<span class="sd">        :meth:`write`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path to the file being written.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdl_mol_block</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_write_pdb_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a ``.pdb`` file of the molecule</span>

<span class="sd">        This function should not be used directly, only via</span>
<span class="sd">        :meth:`write`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The full path to the file being written.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First write the file using rdkit.</span>
        <span class="n">rdkit</span><span class="o">.</span><span class="n">MolToPDBFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="c1"># Edit the file because rkdit does poor atom labelling.</span>
        <span class="n">new_content</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pdb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">pdb</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;HETATM&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">lbl_word</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">rpl_word</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">rpl_word</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lbl_word</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">rpl_word</span><span class="p">))</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lbl_word</span><span class="p">,</span> <span class="n">rpl_word</span><span class="p">)</span>

                <span class="n">new_content</span> <span class="o">+=</span> <span class="n">line</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pdb</span><span class="p">:</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">new_content</span><span class="p">)</span></div>


<div class="viewcode-block" id="StructUnit"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit">[docs]</a><span class="k">class</span> <span class="nc">StructUnit</span><span class="p">(</span><span class="n">Molecule</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">CachedStructUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents the building blocks of macromolecules.</span>

<span class="sd">    The goal of this class is to conveniently store information about,</span>
<span class="sd">    and perform operations on, single instances of macromolecular</span>
<span class="sd">    building blocks.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    init_funcs : :class:`dict`</span>
<span class="sd">        This dictionary holds the various functions which can be used</span>
<span class="sd">        to initialize ``rdkit`` molecules and pairs them with the</span>
<span class="sd">        appropriate file extension.</span>

<span class="sd">    file : :class:`str`</span>
<span class="sd">        The full path to the molecular structure file holding the</span>
<span class="sd">        molecule. The supported file formats are the keys in</span>
<span class="sd">        :attr:`init_funcs`. As long as a file with one of these</span>
<span class="sd">        extensions is provided, the correct initialization function</span>
<span class="sd">        will be used.</span>

<span class="sd">    func_grp : :class:`.FGInfo`</span>
<span class="sd">        The :class:`.FGInfo` instance holding information about the</span>
<span class="sd">        functional group which will react when the building block</span>
<span class="sd">        assembles to form macromolecules.</span>

<span class="sd">    bonder_ids : :class:`list` of :class:`int`</span>
<span class="sd">        A :class:`list` holding the atom ids of the atoms which form</span>
<span class="sd">        bonds during macromolecular assembly.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">init_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;.mol&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">,</span>
                                  <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>

                  <span class="s1">&#39;.sdf&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">,</span>
                                  <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>

                  <span class="s1">&#39;.mol2&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromMol2File</span><span class="p">,</span>
                                   <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>

                  <span class="s1">&#39;.mae&#39;</span><span class="p">:</span> <span class="n">mol_from_mae_file</span><span class="p">,</span>

                  <span class="s1">&#39;.pdb&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromPDBFile</span><span class="p">,</span>
                                  <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">functional_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a :class:`StructUnit` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : :class:`str`</span>
<span class="sd">            The full path of the molecular structure file holding the</span>
<span class="sd">            building block.</span>

<span class="sd">        functional_group : :class:`str`, optional</span>
<span class="sd">            The name of the functional group which is to have atoms</span>
<span class="sd">            tagged. If ``None``, a functional group name found in the</span>
<span class="sd">            path `file`  is used. If no functional group is provided</span>
<span class="sd">            to this parameter and the name of one is not present in</span>
<span class="sd">            `file`, no tagging is done.</span>

<span class="sd">        name : :class:`str`, optional</span>
<span class="sd">            A name which can be optionally given to the molcule for</span>
<span class="sd">            easy identification.</span>

<span class="sd">        note : :class:`str`, optional</span>
<span class="sd">            A note or comment about the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_funcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                   <span class="s1">&#39;Unable to initialize from &quot;</span><span class="si">{}</span><span class="s1">&quot; files.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_funcs</span><span class="p">[</span><span class="n">ext</span><span class="p">](</span><span class="n">file</span><span class="p">)</span>
        <span class="c1"># Update the property cache of each atom. This updates things</span>
        <span class="c1"># like valence.</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">)</span>

        <span class="c1"># Define a generator which yields an ``FGInfo`` instance from</span>
        <span class="c1"># `functional_groups`. The yielded ``FGInfo``instance</span>
        <span class="c1"># represents the functional group of the molecule which will</span>
        <span class="c1"># undergo bond formation. The generator determines the</span>
        <span class="c1"># functional group of the molecule from the path of of the</span>
        <span class="c1"># structure file.</span>

        <span class="c1"># The database of precursors should be organized so that any</span>
        <span class="c1"># given structure file has the name of its functional group in</span>
        <span class="c1"># its path. Each file should have the name of only one</span>
        <span class="c1"># functional group in its path. If this is not the case, the</span>
        <span class="c1"># generator will return the functional group which appears</span>
        <span class="c1"># first in `functional_groups`.</span>

        <span class="c1"># Assign the FGInfo instance from `functional_groups` which</span>
        <span class="c1"># describes the functional group provided in `functional_group`</span>
        <span class="c1"># or is found in the path name.</span>
        <span class="k">if</span> <span class="n">functional_group</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">functional_groups</span> <span class="k">if</span>
                                  <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">functional_group</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">functional_groups</span> <span class="k">if</span>
                                  <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">file</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Calling this function labels the atoms in the rdkit molecule</span>
        <span class="c1"># as either atoms which form a bond during reactions or atoms</span>
        <span class="c1"># which get removed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tag_atoms</span><span class="p">()</span>

<div class="viewcode-block" id="StructUnit.init_random"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.init_random">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_random</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">fg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Picks a random file from `db` to initialize from.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        db : :class:`str`</span>
<span class="sd">            A path to a database of molecular files.</span>

<span class="sd">        fg : :class:`str`, optional</span>
<span class="sd">            The name of a functional group which the molecules in `db`</span>
<span class="sd">            have. By default it is assumed the name is present in the</span>
<span class="sd">            path of the files.</span>

<span class="sd">        name : :class:`str`, optional</span>
<span class="sd">            The name to be given to the created molecule.</span>

<span class="sd">        note : :class:`str`, optional</span>
<span class="sd">            A note to be given to the created molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`StructUnit`</span>
<span class="sd">            A random molecule from `db`.</span>

<span class="sd">        None : :class:`NoneType`</span>
<span class="sd">            If no files in `db` could be initialized from.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">molfile</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">molfile</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Could not initialize </span><span class="si">{}</span><span class="s1"> from </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">molfile</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructUnit.all_bonder_distances"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.all_bonder_distances">[docs]</a>    <span class="k">def</span> <span class="nf">all_bonder_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield distances between all pairs of bonder atoms.</span>

<span class="sd">        All distances are only yielded once. This means that if the</span>
<span class="sd">        distance between atoms with ids ``1`` and ``2``is yielded as</span>
<span class="sd">        ``(12.4, 1, 2)``, no tuple of the form ``(12.4, 2, 1)`` will be</span>
<span class="sd">        yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">           A :class:`tuple` of the form</span>

<span class="sd">           .. code-block:: python</span>

<span class="sd">               (3, 54, 12.54)</span>

<span class="sd">            The first two elements are the ids of the involved atoms</span>
<span class="sd">            and the third element is the distance between them.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through each pair of atoms - do not allow</span>
        <span class="c1"># recombinations.</span>
        <span class="k">for</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span>
                       <span class="n">atom2</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">atom_distance</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">conformer</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructUnit.bonder_centroid"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.bonder_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">bonder_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroid of the bonder atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            An array holding the midpoint of the bonder atoms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">centroid</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span> <span class="k">for</span>
                       <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructUnit.bonder_direction_vectors"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.bonder_direction_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">bonder_direction_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yields the direction vectors between all pairs of bonder atoms.</span>

<span class="sd">        The yielded vector is normalized. If the pair ``(1, 2)`` is</span>
<span class="sd">        yielded, the pair ``(2, 1)`` will not be.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            They yielded tuple has the form</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                (3, 54, np.array([12.2, 43.3, 9.78]))</span>

<span class="sd">            The first two elements of the tuple represent the ids of</span>
<span class="sd">            the start and end atoms of the vector, respectively. The</span>
<span class="sd">            array is the direction vector running between the atomic</span>
<span class="sd">            positions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">atom1_id</span><span class="p">,</span> <span class="n">atom2_id</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom1_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom2_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">atom2_id</span><span class="p">,</span> <span class="n">atom1_id</span><span class="p">,</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">p1</span><span class="o">-</span><span class="n">p2</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.bonder_position_matrix"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.bonder_position_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">bonder_position_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a matrix holding the positions of bonder atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.matrix`</span>
<span class="sd">            The matrix has the shape ``[3, n``. Each column holds the</span>
<span class="sd">            x, y and z coordinates of a bonder atom. The index of the</span>
<span class="sd">            column corresponds to the index of the atom id in</span>
<span class="sd">            :attr:`bonder_ids`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">atom_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">:</span>
            <span class="n">pos_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)])</span>
            <span class="n">pos_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_array</span><span class="p">,</span> <span class="n">pos_vect</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">pos_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.centroid_centroid_dir_vector"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.centroid_centroid_dir_vector">[docs]</a>    <span class="k">def</span> <span class="nf">centroid_centroid_dir_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the direction vector between the 2 molecular centroids.</span>

<span class="sd">        The first molecular centroid is the centroid of the entire</span>
<span class="sd">        molecule. The second molecular centroid is the centroid of the</span>
<span class="sd">        bonder atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            The normalized direction vector running from the centroid</span>
<span class="sd">            of the bonder atoms to the molecular centroid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the bonder centroid and centroid are in the same position,</span>
        <span class="c1"># the centroid - centroid vector should be orthogonal to the</span>
        <span class="c1"># bonder direction vector.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
            <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">bvec</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_direction_vectors</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
            <span class="c1"># Construct a secondary vector by finding the minimum</span>
            <span class="c1"># component of bvec and setting it to 0.</span>
            <span class="n">vec2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bvec</span><span class="p">)</span>
            <span class="n">minc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
            <span class="n">vec2</span><span class="p">[</span><span class="n">vec2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vec2</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">minc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-5</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="c1"># Get a vector orthogonal to bvec and vec2.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span> <span class="o">-</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructUnit.core"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.core">[docs]</a>    <span class="k">def</span> <span class="nf">core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the molecule with no H or functional group atoms.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The &quot;core&quot; of the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">emol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
            <span class="n">atomid</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_core_atom</span><span class="p">(</span><span class="n">atomid</span><span class="p">):</span>
                <span class="n">emol</span><span class="o">.</span><span class="n">RemoveAtom</span><span class="p">(</span><span class="n">atomid</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="n">emol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructUnit.functional_group_atoms"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.functional_group_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">functional_group_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a container of atom ids of atoms in functional groups.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The form of the returned tuple is:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                ((1, 2, 3), (4, 5, 6), (7, 8, 9))</span>

<span class="sd">            This means that all atoms with ids ``1`` to ``9`` are in a</span>
<span class="sd">            functional group and that the atoms ``1``, ``2`` and ``3``</span>
<span class="sd">            all form one functional group together. So do ``4``, ``5``</span>
<span class="sd">            and ``6`` and so on.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate a ``rdkit.Chem.rdchem.Mol`` instance which</span>
        <span class="c1"># represents the functional group of the molecule.</span>
        <span class="n">func_grp_mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="o">.</span><span class="n">fg_smarts</span><span class="p">)</span>

        <span class="c1"># Do a substructure search on the the molecule in `mol` to find</span>
        <span class="c1"># which atoms match the functional group. Return the atom ids</span>
        <span class="c1"># of those atoms.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">func_grp_mol</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.is_core_atom"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.is_core_atom">[docs]</a>    <span class="k">def</span> <span class="nf">is_core_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``True`` if atom is not H or part of the fg.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomid : :class:`int`</span>
<span class="sd">            The id of the atom being queried.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`bool`</span>
<span class="sd">            Indicates whether the atom with `atomid` is part of the</span>
<span class="sd">            core.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Tags are removed by multiprocessing - make sure to reapply</span>
        <span class="c1"># them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tag_atoms</span><span class="p">()</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atomid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s1">&#39;fg&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="StructUnit.json"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.json">[docs]</a>    <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a JSON representation of the molecule.</span>

<span class="sd">        The representation has the following form:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">                &#39;class&#39; : &#39;StructUnit&#39;,</span>
<span class="sd">                &#39;mol_block&#39; : &#39;&#39;&#39;A string holding the V3000 mol</span>
<span class="sd">                                 block of the molecule.&#39;&#39;&#39;,</span>
<span class="sd">                &#39;note&#39; : &#39;This molecule is nice.&#39;,</span>
<span class="sd">                &#39;name&#39; : &#39;benzene&#39;</span>
<span class="sd">            }</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`dict`</span>
<span class="sd">            A :class:`dict` which represents the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">{</span>

            <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s1">&#39;func_grp&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span> <span class="k">if</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="s1">&#39;mol_block&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdl_mol_block</span><span class="p">(),</span>
            <span class="s1">&#39;note&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">note</span><span class="p">,</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="p">}</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_json_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Completes a JSON initialization.</span>

<span class="sd">        This function is not to be used. Use :meth:`Molecule.load`</span>
<span class="sd">        for loading instances from a JSON string. That function will</span>
<span class="sd">        automatically call this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_dict : :class:`dict`</span>
<span class="sd">            A dictionary holding the attribute data of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;r+t&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.mol&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;mol_block&#39;</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;func_grp&#39;</span><span class="p">],</span>
                      <span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">if</span>
                       <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;load_names&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                      <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;note&#39;</span><span class="p">])</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">optimized</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;optimized&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="StructUnit.gen_key"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.gen_key">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gen_key</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">,</span> <span class="n">functional_group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the key used when caching the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdkit_mol : :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            An ``rdkit`` instance of the molecule.</span>

<span class="sd">        functional_group : :class:`str`</span>
<span class="sd">            The name of the functional group being used to make</span>
<span class="sd">            macromolecules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The key used for caching the molecule. Has the form</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                (&#39;amine&#39;, &#39;InChIString&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">functional_group</span><span class="p">,</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolToInchi</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.minimize_theta"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.minimize_theta">[docs]</a>    <span class="k">def</span> <span class="nf">minimize_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule to minimize angle between `v1` and `v2`.</span>

<span class="sd">        The rotation is done about the vector `axis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v1 : :class:`numpy.array`</span>
<span class="sd">            The vector which is rotated.</span>

<span class="sd">        v2 : :class:`numpy.array`</span>
<span class="sd">            The vector which is stationary.</span>

<span class="sd">        axis : :class:`numpy.array`</span>
<span class="sd">            The vector about which the rotation happens.</span>

<span class="sd">        centroid : :class:`numpy.array`</span>
<span class="sd">            The position vector at the center of the rotation.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the vector being rotated is not finite exit. This is</span>
        <span class="c1"># probably due to a planar molecule.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v1</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Save the initial position and change the origin to</span>
        <span class="c1"># `centroid`.</span>
        <span class="n">iposition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="n">centroid</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="c1"># 1. First transform the problem.</span>
        <span class="c1"># 2. The rotation axis is set equal to the z-axis.</span>
        <span class="c1"># 3. Apply this transformation to all vectors in the problem.</span>
        <span class="c1"># 4. Take only the x and y components of `v1` and `v2`.</span>
        <span class="c1"># 5. Work out the angle between them.</span>
        <span class="c1"># 6. Apply that rotation along the original rotation axis.</span>

        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tstart</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstart</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># If the `tstart` vector is 0 after these transformations it</span>
        <span class="c1"># means that it is parallel to the rotation axis, stop.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">iposition</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">tend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">tend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tend</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tend</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">vector_theta</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span>

        <span class="c1"># Check in which direction the rotation should go.</span>
        <span class="c1"># This is done by applying the rotation in each direction and</span>
        <span class="c1"># seeing which one leads to a smaller theta.</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">vector_theta</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">tstart</span><span class="p">),</span> <span class="n">tend</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">(</span><span class="o">-</span><span class="n">angle</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">vector_theta</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">tstart</span><span class="p">),</span> <span class="n">tend</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t2</span> <span class="o">&lt;</span> <span class="n">t1</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">posmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position_from_matrix</span><span class="p">(</span><span class="n">posmat</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">iposition</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.rdkit_init"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.rdkit_init">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">rdkit_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">functional_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses an ``rdkit`` molecule for initialization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mol : :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            An ``rdkit`` molecule used for initialization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`StructUnit`</span>
<span class="sd">            A :class:`StructUnit` of `mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s1">&#39;r+t&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;.mol&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">MolToMolBlock</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">forceV3000</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">functional_group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.rotate2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.rotate2">[docs]</a>    <span class="k">def</span> <span class="nf">rotate2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule by `theta` about `axis`.</span>

<span class="sd">        The rotation occurs about the centroid of the bonder atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : :class:`float`</span>
<span class="sd">            The size of the rotation in radians.</span>

<span class="sd">        axis : :class:`numpy.array`</span>
<span class="sd">            The axis about which rotation happens.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Save the origin position of the bonder atom centroid.</span>
        <span class="n">og_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Change the position of the centroid of the bonder atoms to</span>
        <span class="c1"># the origin so that the rotation occurs about this point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bonder_centroid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Get the rotation matrix.</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_matrix_arbitrary_axis</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Apply the rotation on the original atomic coordinates to get</span>
        <span class="c1"># the new ones.</span>
        <span class="n">new_pos_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="c1"># Set the atomic positions to the new coordinates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position_from_matrix</span><span class="p">(</span><span class="n">new_pos_mat</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="c1"># Return the centroid to its original position.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bonder_centroid</span><span class="p">(</span><span class="n">og_position</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.set_bonder_centroid"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.set_bonder_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">set_bonder_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the molecule so that the bonder centroid is on `position`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        position : :class:`numpy.array`</span>
<span class="sd">            An array holding the desired the position. It holds</span>
<span class="sd">            the x, y and z coordinates, respectively.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule after it has been shifted. The same</span>
<span class="sd">            instance as in :attr:`~Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conf_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span>

        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">center</span>
        <span class="n">new_conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">conf_id</span><span class="p">)</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">()</span>
        <span class="n">new_conf</span><span class="o">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>

        <span class="c1"># Make sure the rkdit molecule has only one conformer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">RemoveConformer</span><span class="p">(</span><span class="n">conf_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">new_conf</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span></div>

    <span class="k">def</span> <span class="nf">_set_orientation2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule by a rotation from `start` to `end`.</span>

<span class="sd">        Given two direction vectors, `start` and `end`, this method</span>
<span class="sd">        applies the rotation required transform `start` to `end` on</span>
<span class="sd">        the molecule. The rotation occurs about the centroid of the</span>
<span class="sd">        molecule.</span>

<span class="sd">        For example, if the `start` and `end` vectors</span>
<span class="sd">        are 45 degrees apart, a 45 degree rotation will be applied to</span>
<span class="sd">        the molecule. The rotation will be along the appropriate</span>
<span class="sd">        direction.</span>

<span class="sd">        The great thing about this method is that you as long as you</span>
<span class="sd">        can associate a gemotric feature of the molecule with a vector,</span>
<span class="sd">        then the molecule can be roatated so that this vector is</span>
<span class="sd">        aligned with `end`. The defined vector can be virtually</span>
<span class="sd">        anything. This means that any geometric feature of the molecule</span>
<span class="sd">        can be easily aligned with any arbitrary axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The difference between this method and</span>
<span class="sd">        :meth:`~Molecule.set_orientation` is about which point the rotation</span>
<span class="sd">        occurs: centroid of bonder atoms versus centroid of entire</span>
<span class="sd">        molecule, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : :class:`numpy.array`</span>
<span class="sd">            A vector which is to be rotated so that it transforms to</span>
<span class="sd">            the `end` vector.</span>

<span class="sd">        end : :class:`numpy.array`</span>
<span class="sd">            This array holds the vector, onto which `start` is rotated.</span>

<span class="sd">        conformer : :class:`int`</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule in :attr:`~Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Normalize the input direction vectors.</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="c1"># Record the position of the molecule then translate the bonder</span>
        <span class="c1"># atom centroid to the origin. This is so that the rotation</span>
        <span class="c1"># occurs about this point.</span>
        <span class="n">og_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bonder_centroid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="c1"># Get the rotation matrix.</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># Apply the rotation matrix to the atomic positions to yield</span>
        <span class="c1"># the new atomic positions.</span>
        <span class="n">new_pos_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

        <span class="c1"># Set the positions in the rdkit molecule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_position_from_matrix</span><span class="p">(</span><span class="n">new_pos_mat</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bonder_centroid</span><span class="p">(</span><span class="n">og_center</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span>

<div class="viewcode-block" id="StructUnit.similar_molecules"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.similar_molecules">[docs]</a>    <span class="k">def</span> <span class="nf">similar_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns molecules from `mols` ordered by similarity.</span>

<span class="sd">        The most similar molecule is at index 0.</span>

<span class="sd">        This method uses the Morgan fingerprints of radius 4 to</span>
<span class="sd">        evaluate how similar the molecules in `mols` are.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mols : :class:`iterable` of :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            A group of molecules to which similarity is compared.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`list`</span>
<span class="sd">            A :class:`list` of the form,</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                returned_list = [(8.9, mol1), (7.3, mol2), (3.4, mol3)]</span>

<span class="sd">            where the :class:`float` is the similarity of a given</span>
<span class="sd">            molecule in `mols` while the ```mol`` is corresponding</span>
<span class="sd">            ``rdkit`` molecule. Most similar molecule yielded first.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First get the fingerprint of `self`.</span>
        <span class="n">rdkit</span><span class="o">.</span><span class="n">GetSSSR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># For every structure file in the database create a rdkit</span>
        <span class="c1"># molecule. Place these in a list.</span>
        <span class="n">similarities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mols</span><span class="p">:</span>
            <span class="n">rdkit</span><span class="o">.</span><span class="n">GetSSSR</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mol_fp</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">GetMorganFingerprint</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">similarity</span> <span class="o">=</span> <span class="n">DataStructs</span><span class="o">.</span><span class="n">DiceSimilarity</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mol_fp</span><span class="p">)</span>
            <span class="n">similarities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">similarity</span><span class="p">,</span> <span class="n">mol</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">similarities</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="StructUnit.smarts_init"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.smarts_init">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">smarts_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                    <span class="n">smarts</span><span class="p">,</span>
                    <span class="n">functional_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize from a SMARTS string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smiles : :class:`str`</span>
<span class="sd">            A SMARTS string of the molecule.</span>

<span class="sd">        functional_group : :class:`str`, optional</span>
<span class="sd">            The name of the functional group which is to have atoms</span>
<span class="sd">            tagged. If no functional group is provided to this</span>
<span class="sd">            parameter, no tagging is done.</span>

<span class="sd">        note : :class:`str`, optional</span>
<span class="sd">            A note or comment about the molecule.</span>

<span class="sd">        name : :class:`str`, optional</span>
<span class="sd">            A name which can be optionally given to the molcule for</span>
<span class="sd">            easy identification.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`StructUnit`</span>
<span class="sd">            A :class:`StructUnit` instance of the molecule in `smarts`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>
        <span class="n">rdkit</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">gen_key</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">functional_group</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">rdkit</span><span class="o">.</span><span class="n">EmbedMolecule</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">Molecule</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">smarts</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">func_grp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">functional_groups</span> <span class="k">if</span>
                            <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">functional_group</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">func_grp</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">tag_atoms</span><span class="p">()</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="StructUnit.tag_atoms"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.tag_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">tag_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds bonding and deletion tags to atoms.</span>

<span class="sd">        All atoms which form the functional group of the molecule have</span>
<span class="sd">        the property ``&#39;fg&#39;`` added. Its value is set to the name of</span>
<span class="sd">        the functional group.</span>

<span class="sd">        The atoms which form bonds during assembly have the property</span>
<span class="sd">        called ``&#39;bonder&#39;`` added and set to ``&#39;1&#39;``. Atoms which are</span>
<span class="sd">        deleted during reactions have the property ``&#39;del&#39;`` set to</span>
<span class="sd">        ``&#39;1&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Clear this list in case the method is being rerun.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Give all atoms in functional groups the tag &#39;fg&#39; and set its</span>
        <span class="c1"># value to the name of the functional group.</span>
        <span class="k">for</span> <span class="n">atom_id</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functional_group_atoms</span><span class="p">()):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s1">&#39;fg&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Give all atoms which form bonds during reactions the tag</span>
        <span class="c1"># &#39;bonder&#39; and set its value to &#39;1&#39;. Add their ids to</span>
        <span class="c1"># `bonder_ids`.</span>
        <span class="n">bond_mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="o">.</span><span class="n">bonder_smarts</span><span class="p">)</span>
        <span class="n">bond_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">bond_mol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_id</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">bond_atoms</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s1">&#39;bonder&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>

        <span class="c1"># Give all atoms which form bonds during reactions the tag</span>
        <span class="c1"># &#39;del&#39; and set its value to &#39;1&#39;.</span>
        <span class="n">del_mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_grp</span><span class="o">.</span><span class="n">del_smarts</span><span class="p">)</span>
        <span class="n">del_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">del_mol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_id</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">del_atoms</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_id</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit.untag_atoms"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit.untag_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">untag_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the tags added by :meth:`tag_atoms`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">ClearProp</span><span class="p">(</span><span class="s1">&#39;fg&#39;</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">ClearProp</span><span class="p">(</span><span class="s1">&#39;bonder&#39;</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">ClearProp</span><span class="p">(</span><span class="s1">&#39;del&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="StructUnit2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit2">[docs]</a><span class="k">class</span> <span class="nc">StructUnit2</span><span class="p">(</span><span class="n">StructUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents building blocks with 2 functional groups.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="StructUnit2.set_orientation2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit2.set_orientation2">[docs]</a>    <span class="k">def</span> <span class="nf">set_orientation2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate the molecule so that bonder atoms lie on `end`.</span>

<span class="sd">        The molecule is rotated about the centroid of the bonder atoms.</span>
<span class="sd">        It is rotated so that the direction vector running between the</span>
<span class="sd">        2 bonder atoms is aligned with the vector `end`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        end : :class:`numpy.array`</span>
<span class="sd">            The vector with which the molecule&#39;s bonder atoms should be</span>
<span class="sd">            aligned.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule in :attr:`~Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_direction_vectors</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_orientation2</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit2.minimize_theta2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit2.minimize_theta2">[docs]</a>    <span class="k">def</span> <span class="nf">minimize_theta2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates molecule about `axis` to minimze theta with `vector`.</span>

<span class="sd">        The molecule is rotated about `axis` passing through the bonder</span>
<span class="sd">        centroid. It is rotated so that the vector between the bonder</span>
<span class="sd">        and molecular centroids lies on the same plane as `vector`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector : :class:`numpy.array`</span>
<span class="sd">            The vector to which the distance should be minimized.</span>

<span class="sd">        axis : :class:`numpy.array`</span>
<span class="sd">            The direction vector along which the rotation happens.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minimize_theta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_centroid_dir_vector</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span>
                            <span class="n">vector</span><span class="p">,</span>
                            <span class="n">axis</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span>
                            <span class="n">conformer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StructUnit3"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit3">[docs]</a><span class="k">class</span> <span class="nc">StructUnit3</span><span class="p">(</span><span class="n">StructUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents building blocks with 3 functional groups.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="StructUnit3.bonder_plane"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit3.bonder_plane">[docs]</a>    <span class="k">def</span> <span class="nf">bonder_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coefficients of the plane formed by bonder atoms.</span>

<span class="sd">        A plane is defined by the scalar plane equation::</span>

<span class="sd">            ax + by + cz = d.</span>

<span class="sd">        This method returns the ``a``, ``b``, ``c`` and ``d``</span>
<span class="sd">        coefficients of this equation for the plane formed by the</span>
<span class="sd">        bonder atoms. The coefficents ``a``, ``b`` and ``c`` decribe</span>
<span class="sd">        the normal vector to the plane. The coefficent ``d`` is found</span>
<span class="sd">        by substituting these coefficients along with the ``x``, ``y``</span>
<span class="sd">        and ``z`` variables in the scalar equation and solving for</span>
<span class="sd">        ``d``. The variables ``x``, ``y`` and ``z`` are substituted by</span>
<span class="sd">        the coordinates of some point on the plane. For example, the</span>
<span class="sd">        position of one of the bonder atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            This array has the form ``[a, b, c, d]`` and represents the</span>
<span class="sd">            scalar equation of the plane formed by the bonder atoms.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        https://tinyurl.com/okpqv6</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bonder_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">conformer</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_plane_normal</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span> <span class="o">*</span> <span class="n">bonder_coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_plane_normal</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit3.bonder_plane_normal"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit3.bonder_plane_normal">[docs]</a>    <span class="k">def</span> <span class="nf">bonder_plane_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the normal vector to the plane formed by bonder atoms.</span>

<span class="sd">        The normal of the plane is defined such that it goes in the</span>
<span class="sd">        direction toward the centroid of the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.array`</span>
<span class="sd">            A unit vector which describes the normal to the plane of</span>
<span class="sd">            the bonder atoms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_direction_vectors</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;StructUnit3 molecule &quot;</span>
                             <span class="s2">&quot;has fewer than 3 functional groups.&quot;</span><span class="p">))</span>

        <span class="n">vgen</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_direction_vectors</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">vgen</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">normal_v</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">vector_theta</span><span class="p">(</span><span class="n">normal_v</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">centroid_centroid_dir_vector</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">normal_v</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">normal_v</span></div>

<div class="viewcode-block" id="StructUnit3.minimize_theta2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit3.minimize_theta2">[docs]</a>    <span class="k">def</span> <span class="nf">minimize_theta2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates molecule to minimize angle between `atom` and `vector`.</span>

<span class="sd">        The rotation is done about `axis` and is centered on the</span>
<span class="sd">        bonder centroid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : :class:`int`</span>
<span class="sd">            The id of atom which is to have angle minimized.</span>

<span class="sd">        vector : :class:`numpy.array`</span>
<span class="sd">            A vector with which the angle is minimized.</span>

<span class="sd">        axis : :class:`numpy.array`</span>
<span class="sd">            The vector about which the rotation happens.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span> <span class="o">-</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimize_theta</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span>
                            <span class="n">vector</span><span class="p">,</span>
                            <span class="n">axis</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bonder_centroid</span><span class="p">(</span><span class="n">conformer</span><span class="p">),</span>
                            <span class="n">conformer</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructUnit3.set_orientation2"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.StructUnit3.set_orientation2">[docs]</a>    <span class="k">def</span> <span class="nf">set_orientation2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the molecule so the plane normal is aligned with `end`.</span>

<span class="sd">        Here &quot;plane normal&quot; referes to the normal of the plane formed</span>
<span class="sd">        by the bonder atoms. The molecule is rotated about the centroid</span>
<span class="sd">        of the bonder atoms. The rotation results in the normal of</span>
<span class="sd">        their plane being aligned with `end`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        end : :class:`numpy.array`</span>
<span class="sd">            The vector with which the normal of plane of bonder atoms</span>
<span class="sd">            shoould be aligned.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule in :attr:`~Molecule.mol`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_plane_normal</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_orientation2</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">conformer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MacroMolecule"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">MacroMolecule</span><span class="p">(</span><span class="n">Molecule</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Cached</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A representing assembled macromolecules.</span>

<span class="sd">    Because of the computational cost associated with macromolecule</span>
<span class="sd">    assembly, instances of this class are cached. This means that</span>
<span class="sd">    providing the same arguments to the initializer will not build a</span>
<span class="sd">    different instance with the same attribute values. It will yield</span>
<span class="sd">    the original instance, retrieved from memory.</span>

<span class="sd">    This class is not intended to be used directly but should be</span>
<span class="sd">    inherited by subclasses representing specific macromolecules. The</span>
<span class="sd">    :class:`Cage` and :class:`Polymer` classes are examples of this.</span>
<span class="sd">    Any information or methods that apply generally to all</span>
<span class="sd">    macromolecule should be defined within this class while specific</span>
<span class="sd">    non-general data should be included in the derived classes.</span>

<span class="sd">    Note the equality operator ``==`` compares :attr:`fitness`. This</span>
<span class="sd">    means two different macromolecules compare equal if they happen to</span>
<span class="sd">    have the same fitness. The operator is not to be used to check if</span>
<span class="sd">    one macromolecule is the same structurally as another. To do this,</span>
<span class="sd">    use :meth:`~Molecule.same`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    building_blocks : :class:`list` of :class:`StructUnit`</span>
<span class="sd">        This attribute holds :class:`StructUnit` instances which</span>
<span class="sd">        represent the monomers forming the macromolecule. Only one</span>
<span class="sd">        :class:`StructUnit` instance is needed per building block, even</span>
<span class="sd">        if multiples of that molecule join up to form the</span>
<span class="sd">        macromolecule.</span>

<span class="sd">    bb_counter : :class:`collections.Counter`</span>
<span class="sd">        A counter keeping track of how much of each building block is</span>
<span class="sd">        used to form the macromolecule.</span>

<span class="sd">    topology : :class:`.Topology`</span>
<span class="sd">        Defines the shape of macromolecule and assembles it.</span>

<span class="sd">    fitness : :class:`float`</span>
<span class="sd">        The fitness value of the macromolecule, used by the GA.</span>

<span class="sd">    unscaled_fitness : :class:`dict`</span>
<span class="sd">        The dictionary holds the name of a fitness function as the</span>
<span class="sd">        key and the value it calculated for unscaled_fitness as the</span>
<span class="sd">        value. For example,</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            unscaled_fitness = {&#39;fitness_func1&#39;: 12.3,</span>
<span class="sd">                                &#39;fitness_func2&#39;: 49.2}</span>

<span class="sd">        where ``&#39;fitness_func1&#39;`` and ``&#39;fitness_func2&#39;`` are the</span>
<span class="sd">        names of the fintess functions applied on the molecule.</span>

<span class="sd">    progress_params : :class:`dict`</span>
<span class="sd">        Holds the fitness parameters which the GA should track to make</span>
<span class="sd">        progress plots. The key is the name of a fitness function. Has</span>
<span class="sd">        the form</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            unscaled_fitness = {&#39;fitness_func1&#39;: [8, 49]</span>
<span class="sd">                                &#39;fitness_func2&#39;: [78, 4.2, 32.3]}</span>


<span class="sd">    bonds_made : :class:`int`</span>
<span class="sd">        The number of bonds made during assembly.</span>

<span class="sd">    bonder_ids : :class:`list` of :class:`int`</span>
<span class="sd">        The ids of atoms which have bonds added during assembly. Sorted</span>
<span class="sd">        from lowest to highest id.</span>

<span class="sd">    fg_ids : :class:`set` of :class:`int`</span>
<span class="sd">        The ids of atoms which were part of the functional group of</span>
<span class="sd">        the building blocks.</span>

<span class="sd">    fragments : :class:`dict`</span>
<span class="sd">        The :class:`dict` has the form</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            fragments = {(0, 0): {1, 2, 3, 4},</span>
<span class="sd">                         (0, 1): {5, 6, 7, 8},</span>
<span class="sd">                         (1, 0): {9, 10, 11},</span>
<span class="sd">                         (1, 1): {12, 13, 14},</span>
<span class="sd">                         (1, 2): {15, 16, 17}}</span>

<span class="sd">        The key in this dictionary is a tuple of form ``(5, 2)``. The</span>
<span class="sd">        first element is the index of a building block within</span>
<span class="sd">        :attr:`building_blocks`. The second element indentifies a</span>
<span class="sd">        molecule of that building block. For example, ``(1, 3)``</span>
<span class="sd">        identifies the 4th molecule of  ``building_blocks[1]`` to be</span>
<span class="sd">        added to the macromolecule during assembly.</span>

<span class="sd">        The value in the dictionary is a set of ints. These hold the</span>
<span class="sd">        atom ids belonging to a particular molecule before assembly.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">building_blocks</span><span class="p">,</span>
                 <span class="n">topology</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">bb_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a :class:`MacroMolecule` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        building_blocks : :class:`list` of :class:`StructUnit`</span>
<span class="sd">            The :class:`StructUnit` instances of building blocks</span>
<span class="sd">            forming the macromolecule.</span>

<span class="sd">        topology : :class:`.Topology`</span>
<span class="sd">            Defines the shape of macromolecule and assembles it.</span>

<span class="sd">        name : :class:`str`, optional</span>
<span class="sd">            A name which can be given to the molcule for easy</span>
<span class="sd">            identification.</span>

<span class="sd">        note : :class:`str`, optional</span>
<span class="sd">            A note or comment about the molecule.</span>

<span class="sd">        bb_conformers : :class:`list` of :class:`int`, optional</span>
<span class="sd">            The ids of the building block conformers to be used. Must</span>
<span class="sd">            be equal in length to `building_blocks` and orders must</span>
<span class="sd">            correspond. If ``None``, then ``-1`` is used for all</span>
<span class="sd">            building blocks.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bb_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bb_conformers</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">building_blocks</span><span class="p">))]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unscaled_fitness</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span> <span class="o">=</span> <span class="n">building_blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fg_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_made</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Ask the ``Topology`` instance to assemble/build the</span>
            <span class="c1"># macromolecule. This creates the `mol` attribute.</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bb_conformers</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Mol</span><span class="p">()</span>
            <span class="n">errormsg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Build failure.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;topology</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;--------</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;building blocks</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;---------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>

            <span class="n">bb_blocks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">building_blocks</span><span class="p">):</span>
                <span class="n">bb_conf</span> <span class="o">=</span> <span class="n">bb_conformers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">bb_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0.__class__.__name__}</span><span class="s1"> </span><span class="si">{0.func_grp.name}</span><span class="se">\n</span><span class="s1">&#39;</span>
                     <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">mdl_mol_block</span><span class="p">(</span><span class="n">bb_conf</span><span class="p">)))</span>

            <span class="n">errormsg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bb_blocks</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errormsg</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_ids</span><span class="p">()</span>

<div class="viewcode-block" id="MacroMolecule.add_conformer"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.add_conformer">[docs]</a>    <span class="k">def</span> <span class="nf">add_conformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bb_conformers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assembles a new conformer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bb_conformers : :class:`list` of :class:`int`</span>
<span class="sd">            The ids of the building block conformers to be used. Must</span>
<span class="sd">            be equal in length to :attr:`building_blocks` and orders</span>
<span class="sd">            must correspond. If ``None``, then ``-1`` is used for all</span>
<span class="sd">            building blocks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`int`</span>
<span class="sd">            The id of the new conformer.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Save the original rdkit molecule.</span>
        <span class="n">original_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span>
        <span class="c1"># Build a new molecule.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Ask the ``Topology`` instance to assemble/build the</span>
            <span class="c1"># macromolecule. This creates the `mol` attribute.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bb_conformers</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Mol</span><span class="p">()</span>
            <span class="n">errormsg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Build failure.</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;topology</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;--------</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;building blocks</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;---------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>

            <span class="n">bb_blocks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span><span class="p">):</span>
                <span class="n">bb_conf</span> <span class="o">=</span> <span class="n">bb_conformers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">bb_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0.__class__.__name__}</span><span class="s1"> </span><span class="si">{0.func_grp.name}</span><span class="se">\n</span><span class="s1">&#39;</span>
                     <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">bb</span><span class="o">.</span><span class="n">mdl_mol_block</span><span class="p">(</span><span class="n">bb_conf</span><span class="p">)))</span>

            <span class="n">errormsg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bb_blocks</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errormsg</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get the new conformer.</span>
        <span class="n">new_conf</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Conformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">())</span>
        <span class="c1"># Add it to the original molecule.</span>
        <span class="n">new_id</span> <span class="o">=</span> <span class="n">original_mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">new_conf</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">original_mol</span>
        <span class="k">return</span> <span class="n">new_id</span></div>

<div class="viewcode-block" id="MacroMolecule.building_block_cores"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.building_block_cores">[docs]</a>    <span class="k">def</span> <span class="nf">building_block_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yields the &quot;cores&quot; of the building block molecules.</span>

<span class="sd">        The structure of the yielded cores has the geometry found in</span>
<span class="sd">        the macromolecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bb : :class:`int`</span>
<span class="sd">            The index of a building block molecule within</span>
<span class="sd">            :attr:`building_blocks`. The cores of this molecule are</span>
<span class="sd">            yielded.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The core of a building block molecule, as found in the</span>
<span class="sd">            macromolecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">bb_index</span><span class="p">,</span> <span class="n">mol_index</span><span class="p">),</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ignore fragments which do not correspond to the molecule</span>
            <span class="c1"># `bb`.</span>
            <span class="k">if</span> <span class="n">bb_index</span> <span class="o">!=</span> <span class="n">bb</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># For each fragment make a new core. To preserver bond</span>
            <span class="c1"># information, start with the macromolecule.</span>
            <span class="n">coremol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
            <span class="c1"># Remove any atoms not part of the core - atoms not in the</span>
            <span class="c1"># fragment itself, hydrogens, atoms in the functional</span>
            <span class="c1"># group.</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
                <span class="n">atomid</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">atomid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="ow">or</span>
                    <span class="n">atomid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_ids</span> <span class="ow">or</span>
                   <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">coremol</span><span class="o">.</span><span class="n">RemoveAtom</span><span class="p">(</span><span class="n">atomid</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">coremol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span></div>

<div class="viewcode-block" id="MacroMolecule.json"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.json">[docs]</a>    <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a JSON representation of the molecule.</span>

<span class="sd">        The representation has the form</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">                &#39;class&#39; : &#39;Polymer&#39;,</span>
<span class="sd">                &#39;mol_block&#39; : &#39;&#39;&#39;A string holding the V3000 mol</span>
<span class="sd">                                 block of the molecule.&#39;&#39;&#39;</span>
<span class="sd">                &#39;building_blocks&#39; : {bb1.json(), bb2.json()}</span>
<span class="sd">                &#39;topology&#39; : &#39;Copolymer(repeating_unit=&quot;AB&quot;)&#39;</span>
<span class="sd">                &#39;unscaled_fitness&#39; : {&#39;fitness_func1&#39; : fitness1,</span>
<span class="sd">                                      &#39;fitness_func2&#39; : fitness2},</span>
<span class="sd">                &#39;note&#39; : &#39;A nice molecule.&#39;,</span>
<span class="sd">                &#39;name&#39; : &#39;Poly-Benzene&#39;</span>
<span class="sd">            }</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`dict`</span>
<span class="sd">            A :class:`dict` which represents the molecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;bb_counter&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">key</span><span class="o">.</span><span class="n">json</span><span class="p">(),</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">bb_counter</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span>
            <span class="s1">&#39;bonds_made&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds_made</span><span class="p">,</span>
            <span class="s1">&#39;bonder_ids&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">,</span>
            <span class="s1">&#39;fg_ids&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fg_ids</span><span class="p">),</span>
            <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s1">&#39;mol_block&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdl_mol_block</span><span class="p">(),</span>
            <span class="s1">&#39;building_blocks&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span><span class="p">],</span>
            <span class="s1">&#39;topology&#39;</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">),</span>
            <span class="s1">&#39;unscaled_fitness&#39;</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unscaled_fitness</span><span class="p">),</span>
            <span class="s1">&#39;progress_params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_params</span><span class="p">,</span>
            <span class="s1">&#39;note&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">note</span><span class="p">,</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;fragments&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                          <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                          <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

        <span class="p">}</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_json_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Completes a JSON initialization.</span>

<span class="sd">        This function is not to be used. Use :meth:`Molecule.load`</span>
<span class="sd">        for loading instances from a JSON string. That function will</span>
<span class="sd">        automatically call this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_dict : :class:`dict`</span>
<span class="sd">            A dictionary holding the attribute data of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Molecule</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
               <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;building_blocks&#39;</span><span class="p">]]</span>

        <span class="n">topology</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;topology&#39;</span><span class="p">],</span>  <span class="n">topologies</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">gen_key</span><span class="p">(</span><span class="n">bbs</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span> <span class="ow">and</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">MolFromMolBlock</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;mol_block&#39;</span><span class="p">],</span>
                                        <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">unscaled_fitness</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;unscaled_fitness&#39;</span><span class="p">],</span>
                                    <span class="n">np</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">progress_params</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;progress_params&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">bb_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">({</span><span class="n">Molecule</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">val</span> <span class="k">for</span>
                                  <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;bb_counter&#39;</span><span class="p">]})</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">bonds_made</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;bonds_made&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;bonder_ids&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">fg_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;fg_ids&#39;</span><span class="p">])</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">optimized</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;optimized&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">note</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;note&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;load_names&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">building_blocks</span> <span class="o">=</span> <span class="n">bbs</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;fragments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;fragments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">))</span>

        <span class="k">if</span> <span class="n">CACHE_SETTINGS</span><span class="p">[</span><span class="s1">&#39;ON&#39;</span><span class="p">]:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="MacroMolecule.gen_key"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.gen_key">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gen_key</span><span class="p">(</span><span class="n">building_blocks</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the key used for caching the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        building_blocks : :class:`list` of :class:`StructUnit`</span>
<span class="sd">            The building blocks used to make the macromolecule.</span>

<span class="sd">        topology : :class:`.Topology`</span>
<span class="sd">            The topology used to make the macromolecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The key used for caching the macromolecule.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">key</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">building_blocks</span><span class="p">),</span>
                <span class="nb">repr</span><span class="p">(</span><span class="n">topology</span><span class="p">))</span></div>

<div class="viewcode-block" id="MacroMolecule.bb_distortion"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.bb_distortion">[docs]</a>    <span class="k">def</span> <span class="nf">bb_distortion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bb_conformers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rmsd difference of building blocks before and after assembly.</span>

<span class="sd">        The function looks at each building block in the macromolecule</span>
<span class="sd">        and calculates the rmsd between the &quot;free&quot; verson and the one</span>
<span class="sd">        present in the macromolecule. The mean of these rmsds is</span>
<span class="sd">        returned.</span>

<span class="sd">        Atoms which form the functional group of the building blocks</span>
<span class="sd">        and hydrogens are excluded from the calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bb_conformers : :class:`list` of :class:`int`</span>
<span class="sd">            The ids of building block conformers to use. 1 id for each</span>
<span class="sd">            building block, in an order corresponding to</span>
<span class="sd">            :attr:`building_blocks`. If ``None``, all conformer ids</span>
<span class="sd">            default to ``-1``.</span>

<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The mean rmsd of the macromole&#39;s building blocks to their</span>
<span class="sd">            &quot;free&quot; counterparts.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bb_conformers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bb_conformers</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span><span class="p">))]</span>

        <span class="c1"># Go through each of the building blocks. For each building</span>
        <span class="c1"># block get the core. Get the corrospending cores in the</span>
        <span class="c1"># macromolecules and add the rmsd to the sum. Increment the</span>
        <span class="c1"># count to calculate the mean later.</span>
        <span class="n">rmsd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span><span class="p">):</span>
            <span class="n">free</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">core</span><span class="p">()</span>
            <span class="n">am</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())]</span>
            <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">building_block_cores</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">rmsd</span> <span class="o">+=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">AlignMol</span><span class="p">(</span><span class="n">free</span><span class="p">,</span>
                                       <span class="n">frag</span><span class="p">,</span>
                                       <span class="n">bb_conformers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                       <span class="n">conformer</span><span class="p">,</span>
                                       <span class="n">atomMap</span><span class="o">=</span><span class="n">am</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rmsd</span> <span class="o">/</span> <span class="n">n</span></div>

<div class="viewcode-block" id="MacroMolecule.save_ids"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.save_ids">[docs]</a>    <span class="k">def</span> <span class="nf">save_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates `bonder_ids` and `fg_ids` attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fg_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s1">&#39;bonder&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s1">&#39;fg&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fg_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="MacroMolecule.update_cache"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.update_cache">[docs]</a>    <span class="k">def</span> <span class="nf">update_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update attributes of cached molecule.</span>

<span class="sd">        When an instance of :class:`MacroMolecule` is first created it</span>
<span class="sd">        is cached. Using ``multiprocessing`` to perform optimizations</span>
<span class="sd">        or calculate fitness returns modified copies of the cached</span>
<span class="sd">        molecules. In order to ensure that the cached molecules have</span>
<span class="sd">        their attributes updated to the values of the copies, this</span>
<span class="sd">        method must be run on the copies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="MacroMolecule.update_fragments"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.update_fragments">[docs]</a>    <span class="k">def</span> <span class="nf">update_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves ``rdkit`` atom properties in :attr:`fragments`.</span>

<span class="sd">        The properties saved are ``&#39;bb_index&#39;`` and ``&#39;mol_index&#39;``.</span>
<span class="sd">        These should be added to the atoms by</span>
<span class="sd">        :meth:`.Topology.place_mols` when running</span>
<span class="sd">        :meth:`.Topology.build`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s1">&#39;bb_index&#39;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">molkey</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;bb_index&#39;</span><span class="p">)),</span>
                      <span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;mol_index&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">molkey</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">fitness</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">fitness</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(building_blocks=</span><span class="si">{}</span><span class="s2">, topology=</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">building_blocks</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following methods are inteded for convenience while</span>
<span class="sd">    debugging or testing and should not be used during typical</span>
<span class="sd">    execution of the program.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MacroMolecule.testing_init"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.MacroMolecule.testing_init">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">testing_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bb1</span><span class="p">,</span> <span class="n">bb2</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>

        <span class="n">key</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">bb1</span><span class="p">,</span> <span class="n">bb2</span><span class="p">}),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">MacroMolecule</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">MacroMolecule</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">macro_mol</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">macro_mol</span><span class="o">.</span><span class="n">building_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">bb1</span><span class="p">,</span> <span class="n">bb2</span><span class="p">]</span>
            <span class="n">macro_mol</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
            <span class="n">MacroMolecule</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">macro_mol</span>
            <span class="k">return</span> <span class="n">macro_mol</span></div></div>


<div class="viewcode-block" id="Cage"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Cage">[docs]</a><span class="k">class</span> <span class="nc">Cage</span><span class="p">(</span><span class="n">MacroMolecule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent molecular cages.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Cage.window_difference"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Cage.window_difference">[docs]</a>    <span class="k">def</span> <span class="nf">window_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total difference in all window sizes.</span>

<span class="sd">        Every combination of windows is considered and all the</span>
<span class="sd">        size differences are summed and returned. Only</span>
<span class="sd">        differences between windows of the same type are</span>
<span class="sd">        considered.</span>

<span class="sd">        Consider a triangular-based prism cage topology. Such a</span>
<span class="sd">        cage will have triangular windows and square windows. You</span>
<span class="sd">        only want to compare the triangulars with other</span>
<span class="sd">        triangular windows and squares only with other squares.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The total difference of window size when considering</span>
<span class="sd">            every combination of windows of the same type.</span>

<span class="sd">        None : :class:`NoneType`</span>
<span class="sd">            If not all windows were found.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_windows</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Cluster the windows into groups so that only size</span>
        <span class="c1"># differences between windows of the same type are taken</span>
        <span class="c1"># into account. To do this, first sort the windows by</span>
        <span class="c1"># size. If two windows types are present split the</span>
        <span class="c1"># windows at the two groups at the point where the window</span>
        <span class="c1"># sizes have the biggest difference. If there are three</span>
        <span class="c1"># types split it at the two biggest differences and so</span>
        <span class="c1"># on.</span>

        <span class="n">diffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">windows</span><span class="p">)))</span>
        <span class="n">sorted_diffs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get indices of where the list should be split.</span>
        <span class="n">split</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_window_types</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sorted_diffs</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Get the sub-lists.</span>
        <span class="n">og</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">og</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
            <span class="n">og</span> <span class="o">=</span> <span class="n">og</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_window_types</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">og</span><span class="p">)</span>

        <span class="c1"># After this sum the differences in each group and then</span>
        <span class="c1"># sum the group totals.</span>
        <span class="n">diff_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">diff_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">w1</span> <span class="o">-</span> <span class="n">w2</span><span class="p">)</span> <span class="k">for</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="ow">in</span>
                           <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">diff_num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">diff_sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff_sum</span> <span class="o">/</span> <span class="n">diff_num</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">diff_sums</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cage.windows"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Cage.windows">[docs]</a>    <span class="k">def</span> <span class="nf">windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conformer</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns window sizes found by ``pyWindow``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conformer : :class:`int`, optional</span>
<span class="sd">            The id of the conformer to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>
<span class="sd">            If the function for finding windows and their sizes</span>
<span class="sd">            found fewer than the required number of windows or</span>
<span class="sd">            if it failed for some other reason.</span>

<span class="sd">        :class:`list` of :class:`float`</span>
<span class="sd">            Each :class:`float` represents the size of a</span>
<span class="sd">            window in the cage. If the window finding function</span>
<span class="sd">            found more than the expected number of windows, only</span>
<span class="sd">            the largest ``n`` windows are returned. Where ``n`` is the</span>
<span class="sd">            number of expected windows for that cage topology.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="c1"># Load an RDKit molecule object to pyWINDOW.</span>

            <span class="c1"># As pyWindow doesnt support multiple conformers, first</span>
            <span class="c1"># make an rdkit molecule holding only the desired conformer.</span>
            <span class="n">new_mol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
            <span class="n">new_mol</span><span class="o">.</span><span class="n">RemoveAllConformers</span><span class="p">()</span>
            <span class="n">new_mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">))</span>

            <span class="n">pw_molecule</span> <span class="o">=</span> <span class="n">pywindow</span><span class="o">.</span><span class="n">molecular</span><span class="o">.</span><span class="n">Molecule</span><span class="o">.</span><span class="n">load_rdkit_mol</span><span class="p">(</span><span class="n">new_mol</span><span class="p">)</span>
            <span class="c1"># Find windows and get a single array with windows&#39; sizes.</span>
            <span class="n">all_windows</span> <span class="o">=</span> <span class="n">pw_molecule</span><span class="o">.</span><span class="n">calculate_windows</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;windows&#39;</span><span class="p">)</span>

        <span class="c1"># If pyWindow failed, return ``None``.</span>
        <span class="k">if</span> <span class="n">all_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">all_windows</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_windows</span><span class="p">,</span>
                             <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_windows</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_windows</span><span class="p">):</span>
            <span class="c1"># Return ``None`` when pyWindow fucks up and outputs</span>
            <span class="c1"># a mistakenly large window size.</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">all_windows</span></div></div>


<div class="viewcode-block" id="Polymer"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Polymer">[docs]</a><span class="k">class</span> <span class="nc">Polymer</span><span class="p">(</span><span class="n">MacroMolecule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent polymers.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="Periodic"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Periodic">[docs]</a><span class="k">class</span> <span class="nc">Periodic</span><span class="p">(</span><span class="n">MacroMolecule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent periodic structures.</span>

<span class="sd">    This class is essentially the same as :class:`MacroMolecule`,</span>
<span class="sd">    with additional methods and attributes relevant to periodic</span>
<span class="sd">    materials being added.</span>

<span class="sd">    The method :meth:`~.MacroMolecule.save_ids` is extended to take</span>
<span class="sd">    into account ids of atoms in perdiodic bonds.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    terminator_coords : :class:`dict`</span>
<span class="sd">        The key is an :class:`int` representing the id of a bonder</span>
<span class="sd">        atom. The value is a :class:`numpy.ndarray` which holds the x,</span>
<span class="sd">        y and z coordinates of a deleter atom attached to the bonder.</span>
<span class="sd">        The coordinates are relative to the bonder atom.</span>

<span class="sd">    periodic_bonds : :class:`list` of :class:`.PeriodicBond`</span>
<span class="sd">        When periodic topologies are assembled, periodic bonds</span>
<span class="sd">        do not get added to the ``rdkit`` molecule in the</span>
<span class="sd">        :attr:`~.MacroMolecule.mol` attribute. Instead,</span>
<span class="sd">        :meth:`~.PeriodicLattice.join_mols` adds</span>
<span class="sd">        :class:`.PeriodicBond` instances representing the bonds into</span>
<span class="sd">        this list.</span>

<span class="sd">    _ids_updated : :class:`bool`</span>
<span class="sd">        Indicates whether periodic bond ids have been updated already</span>
<span class="sd">        by :meth:`save_ids`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">building_blocks</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ids_updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">building_blocks</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">note</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_subterminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">bonder_map</span><span class="p">,</span> <span class="n">bonded</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``True`` if atom is bonded to a terminal one.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For internal use by :meth:`island`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom_id : :class:`int`</span>
<span class="sd">            The id of the atom being checked.</span>

<span class="sd">        bonder_map : :class:`dict`</span>
<span class="sd">            A dictionary which maps the atom id in the island to the</span>
<span class="sd">            equivalent bonder atom in the unit cell.</span>

<span class="sd">        bonded : :class:`set`</span>
<span class="sd">            A set of atom ids of all bonder atoms which have had a</span>
<span class="sd">            bond added by :meth:`_join_island`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`bool`</span>
<span class="sd">            ``True`` if atom is bonded to a terminal atom, ``False``</span>
<span class="sd">            otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If `atom_id` is not in the `bonder_map` it means that the</span>
        <span class="c1"># atom is not a bonder and therefore no terminal atoms need to</span>
        <span class="c1"># be added to it.</span>
        <span class="k">if</span> <span class="n">atom_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bonder_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Get id of the equivalent bonder atom in the original unit</span>
        <span class="c1"># cell.</span>
        <span class="n">bid</span> <span class="o">=</span> <span class="n">bonder_map</span><span class="p">[</span><span class="n">atom_id</span><span class="p">]</span>
        <span class="c1"># Make a set of all bonder atoms in the original unit cell</span>
        <span class="c1"># which were registered as having bonds crossing periodic</span>
        <span class="c1"># boundaries.</span>
        <span class="n">periodic</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">atom1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span><span class="p">}</span>
        <span class="n">periodic</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">atom2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span><span class="p">)</span>
        <span class="c1"># If that atom does have a periodic bond and has not had a</span>
        <span class="c1"># bond added while building the island - it is subterminal and</span>
        <span class="c1"># needs to have a terminal atom attached.</span>
        <span class="k">if</span> <span class="n">bid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">periodic</span> <span class="ow">or</span> <span class="n">atom_id</span> <span class="ow">in</span> <span class="n">bonded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Periodic.island"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Periodic.island">[docs]</a>    <span class="k">def</span> <span class="nf">island</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">terminator</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bond_type</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a terminated supercell.</span>

<span class="sd">        Terminated means that the periodic bonds are replaced with</span>
<span class="sd">        bonds to terminating atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimensions : :class:`list` of :class:`int`</span>
<span class="sd">            A 3 member :class:`list`, holding the number of unit cells</span>
<span class="sd">            in the x, y and z directions used to make the supercell.</span>

<span class="sd">        terminator : :class:`int`, optional</span>
<span class="sd">            The atomic number of the terminating atoms added to the</span>
<span class="sd">            supercell.</span>

<span class="sd">        bond_type : :class:`str`, optional</span>
<span class="sd">            The bond type of bonds to terminating atoms. Valid options</span>
<span class="sd">            include ``&#39;1&#39;``, ``&#39;2&#39;``, ``&#39;3&#39;`` and ``&#39;ar&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            An ``rdkit`` molecule of the island.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cells</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">bonder_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_place_island</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="n">island</span><span class="p">,</span> <span class="n">bonded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_island</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">island</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terminate_island</span><span class="p">(</span><span class="n">island</span><span class="p">,</span>
                                      <span class="n">bonded</span><span class="p">,</span>
                                      <span class="n">bonder_map</span><span class="p">,</span>
                                      <span class="n">terminator</span><span class="p">,</span>
                                      <span class="n">bond_dict</span><span class="p">[</span><span class="n">bond_type</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_join_island</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">island</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds bonds between unit cells of `island`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For internal use by :meth:`island`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cells : nested :class:`list` of :class:`Cell`</span>

<span class="sd">        island : :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The island molecule holding unit cells placed side by</span>
<span class="sd">            side like in a supercell but with no bonds running between</span>
<span class="sd">            them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The first member of the tuple an ``rdkit`` molecule of the</span>
<span class="sd">            island with all bonds between the unit cells added. The</span>
<span class="sd">            second member of the tuple is a :class:`set` of</span>
<span class="sd">            :class:`int`, where each :class:`int` is id of a bonder</span>
<span class="sd">            atom which had a bond added by this function.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">emol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">island</span><span class="p">)</span>
        <span class="n">bonded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># `self.periodic_bonds` holds objects of the</span>
        <span class="c1"># ``PeriodicBond`` class. Each ``PeriodicBond`` object has the</span>
        <span class="c1"># ids of two bonder atoms in the unit cell which are connected</span>
        <span class="c1"># by a bond running across the periodic boundary. The</span>
        <span class="c1"># `direction` attribute descibes the axes along which the</span>
        <span class="c1"># bond is periodic. For example, if `direction1` is [1, 0, 0]</span>
        <span class="c1"># it means that the bonder atom in `periodic_bond.atom1` has a</span>
        <span class="c1"># perdiodic bond connecting it to `periodic_bond.atom2` going</span>
        <span class="c1"># in the positive direction along the x-axis.</span>

        <span class="c1"># When iterating through all the unit cells composing the</span>
        <span class="c1"># island, you can use the `direction` vector to get index of</span>
        <span class="c1"># the unit cell which holds atoms connected the present cell.</span>
        <span class="c1"># Then just form bonds between the correct atoms by mapping</span>
        <span class="c1"># the atom ids in the unit cells to the ids of the equivalent</span>
        <span class="c1"># atoms in the original unit cell  and checking the</span>
        <span class="c1"># `periodic_bond` to see which atom ids are connected.</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">cells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">periodic_bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span><span class="p">:</span>
                <span class="c1"># Get the indices of the cell which holds the atom</span>
                <span class="c1"># bonded to the equivalent atom of</span>
                <span class="c1"># `periodic_bond.atom1` in the present `cell`.</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="n">periodic_bond</span><span class="o">.</span><span class="n">direction</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># ccel as in &quot;connected cell&quot;.</span>
                    <span class="n">ccell</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># `bonder1` is the id of a bonder atom, found in `cell`</span>
                <span class="c1"># and equivalent to `periodic_bond.atom1`, having a</span>
                <span class="c1"># bond added.</span>
                <span class="n">bonder1</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">bonders</span><span class="p">[</span><span class="n">periodic_bond</span><span class="o">.</span><span class="n">atom1</span><span class="p">]</span>
                <span class="c1"># `bonder2` is the id of a bonder atom, found in</span>
                <span class="c1"># `ccell` and equivalent to `periodic_bond.atom2`,</span>
                <span class="c1"># having a bond added.</span>
                <span class="n">bonder2</span> <span class="o">=</span> <span class="n">ccell</span><span class="o">.</span><span class="n">bonders</span><span class="p">[</span><span class="n">periodic_bond</span><span class="o">.</span><span class="n">atom2</span><span class="p">]</span>
                <span class="n">bond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">determine_bond_type</span><span class="p">(</span>
                              <span class="bp">self</span><span class="p">,</span>
                              <span class="n">periodic_bond</span><span class="o">.</span><span class="n">atom1</span><span class="p">,</span>
                              <span class="n">periodic_bond</span><span class="o">.</span><span class="n">atom2</span><span class="p">)</span>
                <span class="n">emol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">bonder1</span><span class="p">,</span> <span class="n">bonder2</span><span class="p">,</span> <span class="n">bond_type</span><span class="p">)</span>
                <span class="n">bonded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bonder1</span><span class="p">)</span>
                <span class="n">bonded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bonder2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">emol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">(),</span> <span class="n">bonded</span>

    <span class="k">def</span> <span class="nf">_terminate_island</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">bonded</span><span class="p">,</span>
                          <span class="n">bonder_map</span><span class="p">,</span> <span class="n">terminator</span><span class="p">,</span> <span class="n">bond_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds atoms to all bonder atoms at the edges of `island`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For internal use by :meth:`island`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        island : :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The island molecule which needs to have terminating atoms</span>
<span class="sd">            added.</span>

<span class="sd">        bonded : :class:`set` of :class:`int`</span>
<span class="sd">            Contains all the ids of all bonder atoms in `island` which</span>
<span class="sd">            have already had a bonded added by :meth:`_join_island`.</span>

<span class="sd">        bonder_map : :class:`dict`</span>
<span class="sd">            This is a mapping of the ids of bonder atoms in the island</span>
<span class="sd">            back to the id of the equivalent atom in the original unit</span>
<span class="sd">            cell.</span>

<span class="sd">        terminator : :class:`int`</span>
<span class="sd">            The atomic number of the terminating atoms added to the</span>
<span class="sd">            supercell.</span>

<span class="sd">        bond_type : :class:`str`</span>
<span class="sd">            A string holding the bond type of bonds to the terminating</span>
<span class="sd">            atoms. Valid options include ``&#39;1&#39;``, ``&#39;2&#39;``, ``&#39;3&#39;``</span>
<span class="sd">            and ``&#39;ar&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`rdkit.Chem.rdchem.Mol`</span>
<span class="sd">            The ``rdkit`` molecule of the final, assembled island.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">iconf</span> <span class="o">=</span> <span class="n">island</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">()</span>
        <span class="n">emol</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">island</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">island</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="c1"># If the atom is not connected to a terminal atom, move on</span>
            <span class="c1"># to the next one.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_subterminal</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">bonder_map</span><span class="p">,</span> <span class="n">bonded</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">tid</span> <span class="o">=</span> <span class="n">emol</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">rdkit</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">terminator</span><span class="p">))</span>
            <span class="n">emol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">bond_type</span><span class="p">)</span>
            <span class="c1"># Get the id of bonder atom in the original unit cell</span>
            <span class="c1"># which is equivalent to `atom`.</span>
            <span class="n">bi</span> <span class="o">=</span> <span class="n">bonder_map</span><span class="p">[</span><span class="n">atom_id</span><span class="p">]</span>
            <span class="c1"># Using the equivalent bonder atom get the position</span>
            <span class="c1"># of the terminating atom relative to the bonder atom. Add</span>
            <span class="c1"># the relative position of the terminating atom and the</span>
            <span class="c1"># position of `atom` to get the final position of the</span>
            <span class="c1"># terminating atom.</span>
            <span class="n">tcoords</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iconf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">))</span> <span class="o">+</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">terminator_coords</span><span class="p">[</span><span class="n">bi</span><span class="p">])</span>
            <span class="n">rdkit_coords</span> <span class="o">=</span> <span class="n">rdkit_geo</span><span class="o">.</span><span class="n">Point3D</span><span class="p">(</span><span class="o">*</span><span class="n">tcoords</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdkit_coords</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">emol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">()</span>
        <span class="c1"># Update the positions of all the terminating atoms in the</span>
        <span class="c1"># conformer.</span>
        <span class="k">for</span> <span class="n">atom_id</span><span class="p">,</span> <span class="n">atom_coords</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">conf</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">atom_id</span><span class="p">,</span> <span class="n">atom_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_place_island</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Places unit cells side by side to form an island.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For internal use by :meth:`island`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimensions : :class:`list` of :class:`int`</span>
<span class="sd">            The number of unit cells in the x, y and z directions to be</span>
<span class="sd">            placed side by side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The first member of the tuple is a :class:`list` holding</span>
<span class="sd">            :class:`Cell` objects, one for each unit cell placed. The</span>
<span class="sd">            :class:`Cell` object is placed within nested lists so that</span>
<span class="sd">            a cell with the coordinates x, y, z can be accessed from</span>
<span class="sd">            the list using ``[x][y][z]``. For example,</span>

<span class="sd">                &gt;&gt;&gt; cells, island, bonder_map = \</span>
<span class="sd">periodic._place_island([4, 4, 4])</span>
<span class="sd">                &gt;&gt;&gt; cells[2][1][3]</span>
<span class="sd">                &lt;Cell at 0x7fa0155d54e0&gt;</span>

<span class="sd">            where the returned :class:`Cell` object represents the</span>
<span class="sd">            3rd unit cell along the x axis, the second along the y axis</span>
<span class="sd">            and the fourth along the z axis.</span>

<span class="sd">            The second member is an ``rdkit`` molecule of the island</span>
<span class="sd">            being built. The third member is a :class:`dict` mapping</span>
<span class="sd">            the ids of bonder atoms in the island back to the id of the</span>
<span class="sd">            equivalent atom in the original unit cell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">cell_dimensions</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">island</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">Mol</span><span class="p">()</span>
        <span class="n">bonder_map</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># For each dimension place a unit cell.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">island</span> <span class="o">=</span> <span class="n">rdkit</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span>
                                <span class="n">island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
                    <span class="c1"># `bonders` maps a bonder id in the original unit</span>
                    <span class="c1"># cell to the one currently being added to the</span>
                    <span class="c1"># island.</span>
                    <span class="n">bonders</span> <span class="o">=</span> <span class="p">{</span><span class="n">bi</span><span class="p">:</span> <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">+</span> <span class="n">bi</span> <span class="k">for</span>
                               <span class="n">bi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">}</span>
                    <span class="n">cells</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">bonders</span><span class="p">)</span>
                    <span class="c1"># &#39;bonder_map&#39; maps all bonder ids in the island</span>
                    <span class="c1"># to the bonder ids in the original unit cell.</span>
                    <span class="n">inverse_bonders</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bonders</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                               <span class="n">bonders</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="n">bonder_map</span> <span class="o">=</span> <span class="n">bonder_map</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span><span class="n">inverse_bonders</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">cells</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">bonder_map</span>

<div class="viewcode-block" id="Periodic.save_ids"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Periodic.save_ids">[docs]</a>    <span class="k">def</span> <span class="nf">save_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save_ids</span><span class="p">()</span>

        <span class="c1"># If the ids of periodic bonds have already been updated, stop.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ids_updated</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Update periodic bonds to hold atom ids directly instead of</span>
        <span class="c1"># indices of the atom ids within `bonder_ids`.</span>
        <span class="k">for</span> <span class="n">pb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span><span class="p">:</span>
            <span class="n">pb</span><span class="o">.</span><span class="n">atom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">[</span><span class="n">pb</span><span class="o">.</span><span class="n">atom1</span><span class="p">]</span>
            <span class="n">pb</span><span class="o">.</span><span class="n">atom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">[</span><span class="n">pb</span><span class="o">.</span><span class="n">atom2</span><span class="p">]</span>

        <span class="c1"># Update terminator_coords to hold atom ids directly instead</span>
        <span class="c1"># of indices of the atom ids within `bonder_ids`.</span>
        <span class="n">terminator_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminator_coords</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">bonder_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonder_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">terminator_coords</span><span class="p">[</span><span class="n">bonder_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminator_coords</span> <span class="o">=</span> <span class="n">terminator_coords</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ids_updated</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Periodic.write_gulp_input"><a class="viewcode-back" href="../../../mtk.molecular.molecules.html#mtk.molecular.molecules.Periodic.write_gulp_input">[docs]</a>    <span class="k">def</span> <span class="nf">write_gulp_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span>
                         <span class="n">cell_fix</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">atom_fix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a GULP input file of the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : :class:`str`</span>
<span class="sd">            The `path` of the file to which the molecule should be</span>
<span class="sd">            written.</span>

<span class="sd">        keywords : :class:`list` of :class:`str`</span>
<span class="sd">            The keywords to be placed on the first line of the input</span>
<span class="sd">            file.</span>

<span class="sd">        cell_fix : :class:`list` of :class:`int`, optional</span>
<span class="sd">            A 6 member list holding the fix parameters for the unit</span>
<span class="sd">            cell.</span>

<span class="sd">        atom_fix : :class:`numpy.array` of :class:`int`, optional</span>
<span class="sd">            An n by 3 array where n is the number of atoms in the</span>
<span class="sd">            unit cell. Each row has the fix parameters for a given</span>
<span class="sd">            atom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : :class:`NoneType`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">atom_fix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">(),</span> <span class="mi">3</span><span class="p">])</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;name </span><span class="si">{}</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="c1"># Write the cell parameters.</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;cell</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># The sizes of cell vectors a, b and c are written first.</span>
            <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">cell_dimensions</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="mi">6</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="c1"># Then angles alpha, beta and gamma.</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">cell_dimensions</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">vector_theta</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)),</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">vector_theta</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)),</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">angle3</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">vector_theta</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">angle1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">angle2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">angle3</span><span class="p">))</span>
            <span class="c1"># Finally the fix parameters for the cell.</span>
            <span class="k">for</span> <span class="n">fix</span> <span class="ow">in</span> <span class="n">cell_fix</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fix</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># Add atom coordinates.</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;cart</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">coords</span><span class="p">),</span> <span class="n">fix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_atom_coords</span><span class="p">(),</span>
                                          <span class="n">atom_fix</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
                <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fix</span><span class="p">]</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> core </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="n">id_</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">fz</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># Add bonds.</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;connect </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> 0 0 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>

            <span class="c1"># Add periodic bonds.</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_bonds</span><span class="p">:</span>
                <span class="n">a1</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">direction</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;connect </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{:+}</span><span class="s1"> </span><span class="si">{:+}</span><span class="s1"> </span><span class="si">{:+}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span>
                                                                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span>
                                                                <span class="n">dz</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Lukas Turcani.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>